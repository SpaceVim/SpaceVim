FUNCTION  <SNR>372_IsLineInCodeSections()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:106
Called 4 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
   12              0.000014   for beginLine in keys(a:codeSections)
    8              0.000011     if a:lineNum >= str2nr(beginLine)
    1              0.000002       if a:lineNum <= a:codeSections[beginLine]
                                    return 1
    1              0.000000       endif
    8              0.000002     endif
   12              0.000004   endfor
                            
    4              0.000002   return 0

FUNCTION  deoplete#custom#_update_cache()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:27
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              let custom_buffer = deoplete#custom#_get_buffer()
                            
                              let s:cached.option = copy(s:custom.option)
                              let s:cached.buffer_option = copy(custom_buffer.option)
                              call extend(s:cached.option, s:cached.buffer_option)
                            
                              let s:cached.source_vars = {}
                              for [name, source] in items(s:custom.source)
                                let s:cached.source_vars[name] = get(source, 'vars', {})
                              endfor
                              for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
                              endfor
                              let s:cached.filter = {}
                              for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
                              endfor
                              for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
                              endfor

FUNCTION  <SNR>330_get_delim()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\delim.vim:269
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " arguments: {{{2
                              "   opts = {
                              "     'direction'   : 'next' | 'prev' | 'current'
                              "     'type'        : 'delim_tex'
                              "                   | 'delim_all'
                              "                   | 'all'
                              "     'side'        : 'open'     | 'close'
                              "                   | 'both'     | 'mid'
                              "                   | 'both_all' | 'open_mid'
                              "  }
                              "
                              "  }}}2
                              " returns: {{{2
                              "   delim = {
                              "     type     : 'delim'
                              "     lnum     : line number
                              "     cnum     : column number
                              "     match    : the actual text match
                              "     augment  : how to match a corresponding open
                              "     groups   : dict of captured groups
                              "     side     : 'open' | 'close' | 'mid'
                              "     class    : [ c1, c2 ] identifies the kind of match_words
                              "     regexone : the regex item, like \1foo
                              "     regextwo : the regex_capture item, like \(group\)foo
                              "   }
                              "
                              " }}}2
                            
                              if !get(b:, 'matchup_delim_enabled', 0)
                                return {}
                              endif
                            
                              call matchup#perf#tic('s:get_delim')
                            
                              let l:save_pos = matchup#pos#get_cursor()
                            
                              call matchup#loader#refresh_match_words()
                            
                              " this contains all the patterns for the specified type and side
                              let l:re = b:matchup_delim_re[a:opts.type][a:opts.side]
                            
                              let l:cursorpos = col('.')
                            
                              let l:insertmode = get(a:opts, 'insertmode', 0)
                              if l:cursorpos > 1 && l:insertmode
                                let l:cursorpos -= 1
                              endif
                              if l:cursorpos > strlen(getline('.')) && stridx("vV\<c-v>", mode()) > -1
                                let l:cursorpos -= 1
                              endif
                            
                              let s:invert_skip = 0
                            
                              if a:opts.direction ==# 'current'
                                let l:check_skip = get(a:opts, 'check_skip', g:matchup_delim_noskips >= 2 || g:matchup_delim_noskips >= 1     && getline(line('.'))[l:cursorpos-1] =~ '[^[:punct:]]')
                                if l:check_skip && matchup#delim#skip(line('.'), l:cursorpos)
                                  return {}
                                endif
                              else
                                " check skip if cursor is not currently in skip
                                let l:check_skip = get(a:opts, 'check_skip', !matchup#delim#skip(line('.'), l:cursorpos) || g:matchup_delim_noskips >= 2)
                              endif
                            
                              let a:opts.cursorpos = l:cursorpos
                            
                              " for current, we want to find matches that end after the cursor
                              " note: we expect this to give false-positives with \ze
                              if a:opts.direction ==# 'current'
                                let l:re .= '\%>'.(l:cursorpos).'c'
                              "  let l:re = '\%<'.(l:cursorpos+1).'c' . l:re
                              endif
                            
                              " allow overlapping delimiters
                              " without this, the > in <tag> would not be found
                              if b:matchup_delim_re[a:opts.type]._engine_info.has_zs[a:opts.side]
                                let l:save_cpo = &cpo
                                noautocmd set cpo-=c
                              else
                                " faster than changing cpo but doesn't work right with \zs
                                let l:re .= '\&'
                              endif
                            
                              " move cursor one left for searchpos if necessary
                              let l:need_restore_cursor = 0
                              if l:insertmode
                                call matchup#pos#set_cursor(line('.'), col('.')-1)
                                let l:need_restore_cursor = 1
                              endif
                            
                              " stopline may depend on the current action
                              let l:stopline = get(a:opts, 'stopline', s:stopline)
                            
                              " in the first pass, we get matching line and column numbers
                              " this is intended to be as fast as possible, with no capture groups
                              " we look for a match on this line (if direction == current)
                              " or forwards or backwards (if direction == next or prev)
                              " for current, we actually search leftwards from the cursor
                              while 1
                                let l:to = matchup#perf#timeout()
                                let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + l:stopline, l:to) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW',               max([line('.') - l:stopline, 1]), l:to)   : searchpos(l:re, 'bcnW', line('.'), l:to)
                                if l:lnum == 0 | break | endif
                            
                                " note: the skip here should not be needed
                                " in 'current' mode, but be explicit
                                if a:opts.direction !=# 'current' && (l:check_skip || g:matchup_delim_noskips == 1     && getline(l:lnum)[l:cnum-1] =~ '[^[:punct:]]') && matchup#delim#skip(l:lnum, l:cnum) && (a:opts.direction ==# 'prev' ? (l:lnum > 1 || l:cnum > 1)     : (l:lnum < line('$') || l:cnum < len(getline('$'))))
                            
                                  " invalid match, move cursor and keep looking
                                  call matchup#pos#set_cursor(a:opts.direction ==# 'next' ? matchup#pos#next(l:lnum, l:cnum) : matchup#pos#prev(l:lnum, l:cnum))
                                  let l:need_restore_cursor = 1
                                  continue
                                endif
                            
                                break
                              endwhile
                            
                              " restore cpo if necessary
                              " note: this messes with cursor position
                              if exists('l:save_cpo')
                                noautocmd let &cpo = l:save_cpo
                                let l:need_restore_cursor = 1
                              endif
                            
                              " restore cursor
                              if l:need_restore_cursor
                                call matchup#pos#set_cursor(l:save_pos)
                              endif
                            
                              call matchup#perf#toc('s:get_delim', 'first_pass')
                            
                              " nothing found, leave now
                              if l:lnum == 0
                                call matchup#perf#toc('s:get_delim', 'nothing_found')
                                return {}
                              endif
                            
                              if matchup#perf#timeout_check()
                                return {}
                              endif
                            
                              let l:skip_state = 0
                              if !l:check_skip && (!&synmaxcol || l:cnum <= &synmaxcol)
                                " XXX: workaround an apparent obscure vim bug where the
                                " reported syntax id is incorrect on the first synID() call
                                call matchup#delim#skip(l:lnum, l:cnum)
                                if matchup#perf#timeout_check()
                                  return {}
                                endif
                            
                                let l:skip_state = matchup#delim#skip(l:lnum, l:cnum)
                              endif
                            
                              " now we get more data about the match in this position
                              " there may be capture groups which need to be stored
                            
                              " result stub, to be filled by the parser when there is a match
                              let l:result = { 'lnum'     : l:lnum, 'cnum'     : l:cnum, 'type'     : '', 'match'    : '', 'augment'  : '', 'groups'   : '', 'side'     : '', 'class'    : [], 'regexone' : '', 'regextwo' : '', 'skip'     : l:skip_state,}
                            
                              for l:type in s:types[a:opts.type]
                                let l:parser_result = l:type.parser(l:lnum, l:cnum, a:opts)
                                if !empty(l:parser_result)
                                  let l:result = extend(l:parser_result, l:result, 'keep')
                                  break
                                endif
                              endfor
                            
                              call matchup#perf#toc('s:get_delim', 'got_results')
                            
                              return empty(l:result.type) ? {} : l:result

FUNCTION  <SNR>346_initFoldState()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:111
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let fileinfo = self.fileinfo
                            
                                if a:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
                                elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
                                endif

FUNCTION  neomake#GetCurrentErrorMsg()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2477
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let entry = neomake#get_nearest_error()
                                if empty(entry)
                                    return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  <SNR>122_parse_options()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:124
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = []
                              let options = {}
                            
                              " Eval
                              let cmdline = (a:cmdline =~# '\\\@<!`.*\\\@<!`') ? s:eval_cmdline(a:cmdline) : a:cmdline
                            
                              for s in split(cmdline, s:re_unquoted_match('\%(\\\@<!\s\)\+'))
                                let s = substitute(s, '\\\( \)', '\1', 'g')
                                let splits = split(s, '\a\a\+\zs:')
                                if len(splits) == 1
                                  let source_name = 'file'
                                  let source_arg = s
                                else
                                  let source_name = splits[0]
                                  let source_arg = join(splits[1:], ':')
                                endif
                                let arg_key = substitute(s, '=\zs.*$', '', '')
                            
                                let name = substitute(tr(arg_key, '-', '_'), '=$', '', '')[1:]
                                if name =~# '^no_'
                                  let name = name[3:]
                                  let value = v:false
                                else
                                  let value = (arg_key =~# '=$') ? s:remove_quote_pairs(s[len(arg_key) :]) : v:true
                                endif
                            
                                if index(keys(defx#init#_user_options()), name) >= 0
                                  let options[name] = value
                                else
                                  call add(args, [source_name, source_arg])
                                endif
                              endfor
                            
                              return [args, options]

FUNCTION  dein#util#_get_runtime_path()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\util.vim:28
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:dein#_runtime_path !=# ''
                                return g:dein#_runtime_path
                              endif
                            
                              let g:dein#_runtime_path = dein#util#_get_cache_path() . '/.dein'
                              call dein#util#_safe_mkdir(g:dein#_runtime_path)
                              return g:dein#_runtime_path

FUNCTION  <SNR>324_stopline_back()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:482
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let stopline_back = line('.') - g:context_filetype#search_offset
                              return (stopline_back <= 1) ? 1 : stopline_back

FUNCTION  neoinclude#get_expr()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:207
Called 1 time
Total time:   0.000032
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000032   0.000019   return neoinclude#util#get_buffer_config(   a:filetype, 'b:neoinclude_exprs',   g:neoinclude#exprs, g:neoinclude#_exprs,   getbufvar(a:bufnr, '&includeexpr'))

FUNCTION  <SNR>326_matched_indentkeys()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:318
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &l:indentexpr ==# ''
                                " Disable auto indent
                                return ''
                              endif
                            
                              " Note: check the last word
                              let checkstr = matchstr(a:input, '\w\+$')
                            
                              for word in filter(map(split(&l:indentkeys, ','), { _, val -> matchstr(val, 'e\|=\zs.*') }), { _, val -> val !=# '' && val =~# '\h\w*' })
                            
                                if word ==# 'e'
                                  let word = 'else'
                                endif
                            
                                let lastpos = len(a:input) - len(word)
                                if checkstr ==# word || (word =~# '^\W\+$' && lastpos >= 0 && strridx(a:input, word) == lastpos)
                                  return word
                                endif
                              endfor
                            
                              return ''

FUNCTION  <SNR>250_auto_save()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:515
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:bm_current_file !=# ''
                                call BookmarkSave(s:bookmark_save_file(g:bm_current_file), 1)
                              endif
                              augroup bm_auto_save
                                autocmd!
                              augroup END

FUNCTION  <SNR>254_dir()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:214
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>254_not_git_dir()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:59
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:102
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>50_wrap_id()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:136
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:spacevim_buffer_index_type == 3
                                let id = s:MESSLETTERS.index_num(a:id)
                              elseif g:spacevim_buffer_index_type == 4
                                let id = a:id
                              else
                                let id = s:MESSLETTERS.bubble_num(a:id, g:spacevim_buffer_index_type)
                              endif
                              return id . ' '

FUNCTION  neoinclude#file_include#get_complete_position()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\file_include.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call neoinclude#initialize()
                            
                              let filetype = neoinclude#util#get_context_filetype()
                              if filetype ==# 'java' || filetype ==# 'haskell'
                                " Cannot complete include path.
                                " You should use omnifunc plugins..
                                return -1
                              endif
                            
                              " Not Filename pattern.
                              let pattern = neoinclude#get_pattern('%', filetype)
                              if (pattern == '' || a:input !~ pattern) && a:input =~ '\*$\|\.\.\+$\|/c\%[ygdrive/]$'
                                " Skip filename completion.
                                return -1
                              endif
                            
                              " Check include pattern.
                              let pattern = neoinclude#get_pattern('%', filetype)
                              if pattern =~ '\w$'
                                let pattern .= '\m\s\+'
                              endif
                              if pattern == '' || a:input !~ pattern
                                return -1
                              endif
                            
                              let match_end = matchend(a:input, pattern)
                              let complete_str = matchstr(a:input[match_end :], '\f\+')
                            
                              let complete_pos = len(a:input) - len(complete_str)
                            
                              let delimiter = neoinclude#get_delimiters(filetype)
                              if delimiter != '' && strridx(complete_str, delimiter) >= 0
                                let complete_pos += strridx(complete_str, delimiter) + 1
                              endif
                            
                              return complete_pos

FUNCTION  <SNR>303_HandleBufWrite()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3612
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000006   if index(s:delayed_update_files, a:fname) == -1
                                call add(s:delayed_update_files, a:fname)
    1              0.000000   endif

FUNCTION  matchup#loader#bufwinenter()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\loader.vim:42
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(b:, 'matchup_delim_enabled', 0)
                                return
                              endif
                              call matchup#loader#init_buffer()

FUNCTION  tagbar#log#debug_enabled()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\log.vim:35
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:LOGGER.debug_enabled()

FUNCTION  <SNR>223_close_floating_win()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\matchparen.vim:678
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:float_id')
                                return
                              endif
                              if win_id2win(s:float_id) > 0
                                call nvim_win_close(s:float_id, 0)
                              endif
                              let s:float_id = 0

FUNCTION  tagbar#log#debug()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\log.vim:27
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:LOGGER.debug(a:msg)

FUNCTION  <SNR>346_getChildrenByName()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:221
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return get(self._childdict, a:tagname, [])

FUNCTION  <SNR>372_GetHeadingLinkGFM()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:158
Called 4 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    4              0.000015   let l:headingLink = tr(a:headingName, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz")
                            
                              " \_^ : start of line
                              " _\+ : one of more underscore _
                              " \| : OR
                              " _\+ : one of more underscore _
                              " \_$ : end of line
    4              0.000015   let l:headingLink = substitute(l:headingLink, "\\_^_\\+\\|_\\+\\_$", "", "g")
                              " Characters that are not alphanumeric, latin1 extended (for accents) and
                              " chinese/korean chars are removed.
                              " \\%#=0: allow this pattern to use the regexp engine he wants. Having
                              " `set re=1` in the vimrc could break this behavior. cf. issue #19
    4              0.000030   let l:headingLink = substitute(l:headingLink, "\\%#=0[^[:alnum:]\u00C0-\u00FF\u0400-\u04ff\u4e00-\u9fbf\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF _-]", "", "g")
    4              0.000011   let l:headingLink = substitute(l:headingLink, " ", "-", "g")
                            
    4              0.000004   if l:headingLink ==# ""
                                let l:nullKey = "<null>"
                                if has_key(g:GFMHeadingIds, l:nullKey)
                                  let g:GFMHeadingIds[l:nullKey] += 1
                                  let l:headingLink = l:headingLink . "-" . g:GFMHeadingIds[l:nullKey]
                                else
                                  let g:GFMHeadingIds[l:nullKey] = 0
                                endif
    4              0.000007   elseif has_key(g:GFMHeadingIds, l:headingLink)
                                let g:GFMHeadingIds[l:headingLink] += 1
                                let l:headingLink = l:headingLink . "-" . g:GFMHeadingIds[l:headingLink]
    4              0.000001   else
    4              0.000006     let g:GFMHeadingIds[l:headingLink] = 0
    4              0.000001   endif
                            
    4              0.000003   return l:headingLink

FUNCTION  defx#util#rpcrequest()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:219
Called 1 time
Total time:   0.000342
 Self time:   0.000330

count  total (s)   self (s)
    1   0.000017   0.000014   if !defx#init#_check_channel()
                                return -1
    1              0.000000   endif
                            
    1   0.000019   0.000011   if defx#util#has_yarp()
                                if g:defx#_yarp.job_is_dead
                                  return -1
                                endif
                                if a:is_async
                                  return g:defx#_yarp.notify(a:method, a:args)
                                else
                                  return g:defx#_yarp.request(a:method, a:args)
                                endif
    1              0.000000   else
    1              0.000001     if a:is_async
                                  return rpcnotify(g:defx#_channel_id, a:method, a:args)
    1              0.000000     else
    1              0.000291       return rpcrequest(g:defx#_channel_id, a:method, a:args)
                                endif
                              endif

FUNCTION  <SNR>326_on_insert_leave()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:362
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call deoplete#mapping#_restore_completeopt()
                              let g:deoplete#_context = {}
                              call deoplete#init#_prev_completion()
                            
                              if &cpoptions =~# '$'
                                " If 'cpoptions' includes '$' with popup, redraw problem exists.
                                redraw
                              endif

FUNCTION  neomake#utils#get_verbosity()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:5
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000004     if a:0 && has_key(a:1, 'make_id')
                                    return neomake#GetMakeOptions(a:1.make_id).verbosity
    2              0.000001     endif
    2              0.000004     return get(g:, 'neomake_verbose', 1) + &verbose

FUNCTION  tagbar#state#get_current_file()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\state.vim:1
Called 1 time
Total time:   0.000035
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000034   0.000016     return s:get().getCurrent(a:force_current)

FUNCTION  defx#init#_context()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\init.vim:138
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let buffer_name = get(a:user_context, 'buffer_name', 'default')
                              let context = s:internal_options()
                              call extend(context, defx#init#_user_options())
                              let custom = defx#custom#_get()
                              if has_key(custom.option, '_')
                                call extend(context, custom.option['_'])
                              endif
                              if has_key(custom.option, buffer_name)
                                call extend(context, custom.option[buffer_name])
                              endif
                              call extend(context, a:user_context)
                              return context

FUNCTION  neomake#utils#GetSupersetOf()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:140
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !has_key(s:super_ft_cache, a:ft)
                                    call neomake#utils#load_ft_makers(a:ft)
                                    let l:SupersetOf = 'neomake#makers#ft#'.a:ft.'#SupersetOf'
                                    if exists('*'.SupersetOf)
                                        let s:super_ft_cache[a:ft] = call(SupersetOf, [])
                                    else
                                        let s:super_ft_cache[a:ft] = ''
                                    endif
                                endif
                                return s:super_ft_cache[a:ft]

FUNCTION  <SNR>50_is_modified()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:178
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return getbufvar(a:nr, '&modified', 0)

FUNCTION  <SNR>40_modes()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:176
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001   if g:spacevim_statusline_unicode
    1              0.000001     let m = ' ❖ '
                              else
                                let m = ' # '
    1              0.000000   endif
    2              0.000002   for mode in s:loaded_modes
    1              0.000001     if g:spacevim_statusline_unicode
    1              0.000003       let m .= s:modes[mode].icon . ' '
                                else
                                  let m .= s:modes[mode].icon_asc . ' '
    1              0.000000     endif
    2              0.000001   endfor
    1              0.000001   return m . ' '

FUNCTION  neoinclude#util#async_system()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:69
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let command = s:iconv(a:command, &encoding, 'char')
                            
                              if has('job')
                                return job_start(command)
                              elseif has('nvim')
                                return jobstart(command)
                              else
                                return neoinclude#util#system(a:command)
                              endif

FUNCTION  neomake#utils#GetSetting()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:211
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let maker_only = a:0 ? a:1 : 0
                            
                                " Check new-style config.
                                if exists('g:neomake') || !empty(getbufvar(a:bufnr, 'neomake'))
                                    let context = {'ft': a:ft, 'maker': a:maker, 'bufnr': a:bufnr, 'maker_only': maker_only}
                                    let [l:Ret, source] = neomake#config#get_with_source(a:key, g:neomake#config#undefined, context)
                                    " Check old-style setting when source is the maker.
                                    if source ==# 'maker' && !maker_only
                                        let tmpmaker = {}
                                        if has_key(a:maker, 'name')
                                            let tmpmaker.name = a:maker.name
                                        endif
                                        let l:RetOld = s:get_oldstyle_setting(a:key, tmpmaker, s:unset, a:ft, a:bufnr, 1)
                                        if RetOld isnot# s:unset
                                            return RetOld
                                        endif
                                    endif
                                    if Ret isnot g:neomake#config#undefined
                                        return Ret
                                    endif
                                endif
                            
                                return s:get_oldstyle_setting(a:key, a:maker, a:default, a:ft, a:bufnr, maker_only)

FUNCTION  neosnippet#handlers#_all_clear_markers()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\handlers.vim:23
Called 1 time
Total time:   0.000037
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000001   if !&l:modifiable
                                return
    1              0.000000   endif
                            
    1              0.000002   let pos = getpos('.')
                            
    1              0.000001   try
    1   0.000022   0.000017     while !empty(neosnippet#variables#expand_stack())
                                  call neosnippet#view#_clear_markers( neosnippet#variables#expand_stack()[-1])
                                  stopinsert
    1              0.000000     endwhile
    1              0.000001   finally
    1              0.000002     call setpos('.', pos)
    1              0.000000   endtry

FUNCTION  <SNR>303_TagbarBufName()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3686
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('t:tagbar_buf_name')
                                let s:buffer_seqno += 1
                                let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
                              endif
                            
                              return t:tagbar_buf_name

FUNCTION  <SNR>346_isPseudoTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:59
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 0

FUNCTION  <SNR>221_reltimefloat()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\perf.vim:103
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return reltimefloat(a:time)

FUNCTION  neosnippet#commands#_make_cache()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\commands.vim:70
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call neosnippet#init#check()
                            
                              let filetype = a:filetype ==# '' ? &filetype : a:filetype
                              if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
                              let snippets = neosnippet#variables#snippets()
                              if has_key(snippets, filetype)
                                return
                              endif
                            
                              let snippets[filetype] = {}
                            
                              let cache_dir = neosnippet#variables#data_dir()
                            
                              for filename in neosnippet#helpers#get_snippets_files(filetype)
                                " Clear cache file
                                call s:Cache.deletefile(cache_dir, filename)
                                let snippets[filetype] = extend(snippets[filetype], neosnippet#parser#_parse_snippets(filename))
                              endfor
                            
                              if g:neosnippet#enable_snipmate_compatibility
                                " Load file snippets
                                for filename in neosnippet#helpers#get_snippet_files(filetype)
                                  let trigger = fnamemodify(filename, ':t:r')
                                  let snippets[filetype][trigger] = neosnippet#parser#_parse_snippet(filename, trigger)
                                endfor
                              endif

FUNCTION  neomake#virtualtext#handle_current_error()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\virtualtext.vim:78
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    " Clean always.
                                    if !empty(s:cur_virtualtext)
                                        if bufexists(s:cur_virtualtext[0])
                                            call nvim_buf_clear_highlight(s:cur_virtualtext[0], s:cur_virtualtext[1], 0, -1)
                                        endif
                                    endif
                                    if !get(g:, 'neomake_virtualtext_current_error', 1)
                                        return
                                    endif
                                    let entry = neomake#get_nearest_error()
                                    if empty(entry)
                                        let s:cur_virtualtext = []
                                    else
                                        " Only add it when there is none already (stacking is not
                                        " supported).  https://github.com/neovim/neovim/issues/9285
                                        let buf_info = getbufvar(entry.bufnr, '_neomake_info', {})
                                        if index(get(buf_info, 'virtual_text_entries', []), entry.lnum) == -1
                                            let src_id = neomake#virtualtext#add_entry(entry, s:current_ns)
                                            let s:cur_virtualtext = [bufnr('%'), src_id]
                                        endif
                                    endif

FUNCTION  defx#do_action()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx.vim:43
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &l:filetype !=# 'defx'
                                return ''
                              endif
                            
                              let args = defx#util#convert2list(get(a:000, 0, []))
                              return printf(":\<C-u>call defx#call_action(%s, %s)\<CR>", string(a:action), string(args))

FUNCTION  <SNR>131_get()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\config.vim:41
Called 1 time
Total time:   0.000122
 Self time:   0.000073

count  total (s)   self (s)
    4              0.000003     for prefix in a:prefixes
    3   0.000102   0.000052         let [c, k] = s:resolve_name(a:dict, prefix + a:parts[0:-1], 0, 1)
    3              0.000004         if has_key(c, k)
                                        return [prefix, get(c, k)]
    3              0.000001         endif
    4              0.000001     endfor
    1              0.000001     return [[], g:neomake#config#undefined]

FUNCTION  <SNR>303_IsValidFile()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3414
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('Checking if file is valid [' . a:fname . ']')
                            
                              if a:fname ==# '' || a:ftype ==# ''
                                call tagbar#log#debug('Empty filename or type')
                                return 0
                              endif
                            
                              if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                call tagbar#log#debug('File not readable')
                                return 0
                              endif
                            
                              if getbufvar(a:fname, 'tagbar_ignore') == 1
                                call tagbar#log#debug('File is marked as ignored')
                                return 0
                              endif
                            
                              let winnr = bufwinnr(a:fname)
                              if winnr != -1 && getwinvar(winnr, '&diff')
                                call tagbar#log#debug('Window is in diff mode')
                                return 0
                              endif
                            
                              if &previewwindow
                                call tagbar#log#debug('In preview window')
                                return 0
                              endif
                            
                              if !has_key(s:known_types, a:ftype)
                                if exists('g:tagbar_type_' . a:ftype)
                                  " Filetype definition must have been specified in an 'ftplugin'
                                  " file, so load it now
                                  call s:LoadUserTypeDefs(a:ftype)
                                else
                                  call tagbar#log#debug('Unsupported filetype: ' . a:ftype)
                                  return 0
                                endif
                              endif
                            
                              return 1

FUNCTION  <SNR>195_GuiCursorMoved()
    Defined: D:\Scoop\apps\neovim\current\bin\..\share\nvim-qt\runtime\plugin\nvim_gui_shim.vim:220
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            	let l:minLineVisible = line('w0')
                            	let l:bufferSize = line('$')
                            	let l:windowHeight = winheight(winnr())
                            	call rpcnotify(0, 'Gui', 'CursorMoved', l:minLineVisible, l:bufferSize, l:windowHeight)

FUNCTION  tagbar#prototypes#basetag#new()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:10
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let newobj = {}
                            
                                let newobj.name          = a:name
                                let newobj.fields        = {}
                                let newobj.fields.line   = 0
                                let newobj.fields.column = 0
                                let newobj.fields.end    = 0
                                let newobj.prototype     = ''
                                let newobj.data_type     = ''
                                let newobj.path          = ''
                                let newobj.fullpath      = a:name
                                let newobj.depth         = 0
                                let newobj.parent        = {}
                                let newobj.tline         = -1
                                let newobj.fileinfo      = {}
                                let newobj.typeinfo      = {}
                                let newobj._childlist    = []
                                let newobj._childdict    = {}
                            
                                let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
                                let newobj.isPseudoTag = function(s:add_snr('s:isPseudoTag'))
                                let newobj.isSplitTag = function(s:add_snr('s:isSplitTag'))
                                let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
                                let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                                let newobj.getDataType = function(s:add_snr('s:getDataType'))
                                let newobj._getPrefix = function(s:add_snr('s:_getPrefix'))
                                let newobj.initFoldState = function(s:add_snr('s:initFoldState'))
                                let newobj.getClosedParentTline = function(s:add_snr('s:getClosedParentTline'))
                                let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
                                let newobj.isFolded = function(s:add_snr('s:isFolded'))
                                let newobj.openFold = function(s:add_snr('s:openFold'))
                                let newobj.closeFold = function(s:add_snr('s:closeFold'))
                                let newobj.setFolded = function(s:add_snr('s:setFolded'))
                                let newobj.openParents = function(s:add_snr('s:openParents'))
                                let newobj.addChild = function(s:add_snr('s:addChild'))
                                let newobj.getChildren = function(s:add_snr('s:getChildren'))
                                let newobj.getChildrenByName = function(s:add_snr('s:getChildrenByName'))
                                let newobj.removeChild = function(s:add_snr('s:removeChild'))
                            
                                return newobj

FUNCTION  matchup#pos#set_cursor()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\pos.vim:10
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call cursor(s:parse_args(a:000))

FUNCTION  SpaceVim#layers#core#statusline#_current_tag()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:374
Called 1 time
Total time:   0.000732
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000001   let tag = ''
    1              0.000000   try
    1   0.000728   0.000011     let tag =tagbar#currenttag('%s ', '') 
                              catch
    1              0.000000   endtry
    1              0.000001   return tag

FUNCTION  <SNR>326_completion_timer_stop()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:125
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:completion_timer')
                                return
                              endif
                            
                              call timer_stop(s:completion_timer)
                              unlet s:completion_timer

FUNCTION  deoplete#util#convert2list()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:20
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  neosnippet#util#get_cur_text()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\util.vim:85
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))

FUNCTION  neomake#log#debug()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\log.vim:147
Called 2 times
Total time:   0.000086
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000086   0.000023     call call('s:log', [3] + a:000)

FUNCTION  SpaceVim#api#import()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api.vim:37
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has_key(s:apis, a:name)
                                return deepcopy(s:apis[a:name])
                              endif
                              let p = {}
                              try
                                let p = SpaceVim#api#{a:name}#get()
                                let s:apis[a:name] = deepcopy(p)
                              catch /^Vim\%((\a\+)\)\=:E117/
                              endtry
                              return p

FUNCTION  defx#util#has_textprop()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:43
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return v:version >= 802 && exists('*prop_add')

FUNCTION  <SNR>40_current_tag()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:370
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return '%{SpaceVim#layers#core#statusline#_current_tag()}'

FUNCTION  <SNR>326_is_skip()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:218
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:event ==# 'TextChangedP' && !empty(v:completed_item)
                                return 1
                              endif
                            
                              " Note: The check is needed for <C-y> mapping
                              if s:is_skip_prev_text(a:event)
                                return 1
                              endif
                            
                              if s:is_skip_text(a:event)
                                " Close the popup
                                if deoplete#util#check_popup()
                                  call feedkeys("\<Plug>_", 'i')
                                endif
                            
                                return 1
                              endif
                            
                              " Check nofile buffers
                              if &l:buftype =~# 'nofile' && bufname('%') !=# '[Command Line]'
                                let nofile_complete_filetypes = deoplete#custom#_get_option( 'nofile_complete_filetypes')
                                if index(nofile_complete_filetypes, &l:filetype) < 0
                                  return 1
                                endif
                              endif
                            
                              let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
                              if &paste || (a:event !=# 'Manual' && a:event !=# 'Update' && !auto_complete) || v:insertmode !=# 'i'
                                return 1
                              endif
                            
                              return 0

FUNCTION  <SNR>126_skip_for_running_jobs()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:604
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let running_jobs = values(filter(copy(neomake#_get_s().jobs), 'v:val.bufnr == a:bufnr' .' && v:val.file_mode == 1' .' && !get(v:val, "automake", 0)' ." && !get(v:val, 'canceled')"))
                                if !empty(running_jobs)
                                    call s:debug_log(printf('skipping for already running jobs: %s', string(map(running_jobs, 'v:val.as_string()'))), {'bufnr': a:bufnr})
                                    return 1
                                endif

FUNCTION  <SNR>372_GetBeginFence()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:348
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000001   if a:isModeline != 0
                                return "<!-- " . g:vmt_fence_text . " -->"
    1              0.000000   else
    1              0.000002     return "<!-- ". g:vmt_fence_text . " " . a:markdownStyle . " -->"
                              endif

FUNCTION  neosnippet#mappings#_clear_select_mode_mappings()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\mappings.vim:31
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !g:neosnippet#disable_select_mode_mappings || !exists('*execute')
                                return
                              endif
                            
                              let mappings = execute('smap', 'silent!')
                            
                              for map in map(filter(split(mappings, '\n'), "v:val !~# '^s' && v:val !~# '^\\a*\\s*<\\S\\+>'"), "matchstr(v:val, '^\\a*\\s*\\zs\\S\\+')")
                                silent! execute 'sunmap' map
                                silent! execute 'sunmap <buffer>' map
                              endfor
                            
                              " Define default select mode mappings.
                              snoremap <CR>     a<BS>
                              snoremap <BS>     a<BS>
                              snoremap <Del>    a<BS>
                              snoremap <C-h>    a<BS>

FUNCTION  deoplete#util#get_input()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:27
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mode = mode()
                              if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
                              let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
                              return input

FUNCTION  neomake#config#get_with_source()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\config.vim:70
Called 1 time
Total time:   0.000392
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000008     let context = a:0 > 1 ? a:2 : {'ft': &filetype, 'bufnr': bufnr('%')}
    1              0.000007     let parts = type(a:name) == type([]) ? a:name : split(a:name, '\.')
                            
    1              0.000001     let prefixes = [[]]
    1              0.000003     if has_key(context, 'ft') && !empty(context.ft)
    3   0.000049   0.000021         for ft in neomake#utils#get_config_fts(context.ft, '.')
    2              0.000004             call insert(prefixes, ['ft', ft], 0)
    3              0.000001         endfor
    1              0.000000     endif
                            
    1              0.000003     let maker_name = get(get(context, 'maker', {}), 'name', '')
    1              0.000002     let maker_only = get(context, 'maker_only', 0)
    1              0.000002     if parts[0][0:1] ==# 'b:'
                                    if !has_key(context, 'bufnr')
                                        let context.bufnr = bufnr('%')
                                    endif
                                    let parts[0] = parts[0][2:-1]
                                    if context.bufnr is# ''
                                        let lookups = []
                                    else
                                        let lookups = [['buffer', getbufvar(context.bufnr, 'neomake')]]
                                    endif
                                    call add(lookups, ['maker', get(context, 'maker', {})])
    1              0.000002     elseif empty(maker_name) && maker_only
                                    let lookups = [['maker', get(context, 'maker', {})]]
    1              0.000000     else
    1              0.000015         let lookups = (has_key(context, 'bufnr') && context.bufnr isnot# ''  ? [['buffer', getbufvar(context.bufnr, 'neomake')]]  : []) + [ ['tab', get(t:, 'neomake', {})], ['global', get(g:, 'neomake', {})], ['maker', get(context, 'maker', {})]]
    1              0.000001         if !empty(maker_name)
                                        if maker_only
                                            if parts[0] !=# maker_name
                                                call map(prefixes, 'add(v:val, maker_name)')
                                            endif
                                        else
                                            for prefix in reverse(copy(prefixes))
                                                call insert(prefixes, prefix + [maker_name], 0)
                                            endfor
                                        endif
    1              0.000000         endif
    1              0.000000     endif
                            
    5              0.000005     for [source, lookup] in lookups
    4              0.000004         if !empty(lookup)
    1              0.000001             if source ==# 'maker'
                                            let maker_prefixes = map(copy(prefixes), '!empty(v:val) && v:val[-1] ==# maker_name ? v:val[:-2] : v:val')
                                            let maker_setting_parts = parts[0] == maker_name ? parts[1:] : parts
                                            let [prefix, l:R] = s:get(lookup, maker_setting_parts, maker_prefixes)
    1              0.000000             else
    1   0.000136   0.000013                 let [prefix, l:R] = s:get(lookup, parts, prefixes)
    1              0.000000             endif
    1              0.000001             if R isnot# g:neomake#config#undefined
                                            let log_name = join(map(copy(parts), "substitute(v:val, '\\.', '|', '')"), '.')
                                            let log_source = get(context, 'log_source', '')
                                            call neomake#log#debug(printf( "Using setting %s=%s from '%s'%s%s.", log_name, string(R), source,   empty(prefix) ? '' : ' (prefix: '.string(prefix).')',   empty(log_source) ? '' : ' ('.log_source.')'), context)
                                            return [R, source]
    1              0.000000             endif
    1              0.000001             unlet R  " for Vim without patch-7.4.1546
    4              0.000001         endif
    4              0.000003         unlet lookup  " for Vim without patch-7.4.1546
    5              0.000002     endfor
                            
                                " Return default.
    1              0.000001     if a:0
    1              0.000001         return [a:1, 'default']
                                elseif has_key(g:neomake#config#_defaults, a:name)
                                    return [copy(g:neomake#config#_defaults[a:name]), 'default']
                                endif
                                return [g:neomake#config#undefined, 'default']

FUNCTION  SpaceVim#plugins#windowsmanager#MarkBaseWin()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\windowsmanager.vim:74
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:unmarked
                                let win_data = s:restore_windows_stack[-1]
                                if win_data.same_w
                                  " split
                                  if win_data.oldwinid == winnr()
                                    let win_data.open_command = 'topleft split ' . win_data.bufname
                                  else
                                    let win_data.open_command = 'rightbelow split ' . win_data.bufname
                                  endif
                                else
                                  " vsplit
                                  if win_data.oldwinid == winnr()
                                    let win_data.open_command = 'topleft vsplit ' . win_data.bufname
                                  else
                                    let win_data.open_command = 'rightbelow vsplit ' . win_data.bufname
                                  endif
                                endif
                                let s:unmarked = 0
                              endif

FUNCTION  neosnippet#init#check()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\init.vim:14
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:is_initialized')
                                call neosnippet#init#_initialize()
                              endif

FUNCTION  <SNR>344_reset()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\fileinfo.vim:106
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let self.mtime = getftime(self.fpath)
                                let self._taglist = []
                                let self._tagdict = {}
                                let self.fline = {}
                                let self.tline = {}
                            
                                let self._tagfolds_old = self.tagfolds
                                let self.tagfolds = {}
                            
                                for kind in self.typeinfo.kinds
                                    let self.tagfolds[kind.short] = {}
                                endfor

FUNCTION  cscope#onChange()
    Defined: ~\.SpaceVim\bundle\cscope.vim\autoload\cscope.vim:393
Called 1 time
Total time:   0.000369
 Self time:   0.000352

count  total (s)   self (s)
    1   0.000360   0.000343   let m_dir = s:GetBestPath(expand('%:p:h'))
    1              0.000001   if m_dir != ''
                                let s:dbs[m_dir]['dirty'] = 1
                                call s:FlushIndex()
                                call s:CheckNewFile(s:dbs[m_dir].root, expand('%:p'))
                                redraw
    1              0.000000   endif

FUNCTION  gitgutter#setup_maps()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter.vim:107
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !g:gitgutter_map_keys
                                return
                              endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
                              let bufnr = bufnr('')
                            
                              if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
                                return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  defx#util#call_atomic()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:456
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let results = []
                              for [name, args] in a:calls
                                try
                                  call add(results, call(name, args))
                                catch
                                  call defx#util#print_error(v:exception)
                                  return [results, v:exception]
                                endtry
                              endfor
                              return [results, v:null]

FUNCTION  <SNR>254_is_file_buffer()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:63
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>372_GetEndFencePattern()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:368
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return "<!-- " . g:vmt_fence_closing_text . " -->"

FUNCTION  defx#custom#_get()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\custom.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:custom')
                                call defx#custom#_init()
                              endif
                            
                              return s:custom

FUNCTION  SpaceVim#logger#derive()
    Defined: ~\.SpaceVim\autoload\SpaceVim\logger.vim:101
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return luaeval('require("spacevim.logger").derive(require("spacevim").eval("a:name"))')

FUNCTION  deoplete#util#has_yarp()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:130
Called 1 time
Total time:   0.000025
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000025   0.000021   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  <SNR>303_SetStatusLine()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3458
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tagbarwinnr = bufwinnr(s:TagbarBufName())
                              if tagbarwinnr == -1 || exists('g:tagbar_no_status_line')
                                return
                              endif
                            
                              " Make sure we're actually in the Tagbar window
                              if tagbarwinnr != winnr()
                                let in_tagbar = 0
                                let prevwinnr = winnr()
                                call s:goto_win('p', 1)
                                let pprevwinnr = winnr()
                                call s:goto_win(tagbarwinnr, 1)
                              else
                                let in_tagbar = 1
                              endif
                            
                              if !empty(tagbar#state#get_current_file(0))
                                let fileinfo = tagbar#state#get_current_file(0)
                                let fname = fnamemodify(fileinfo.fpath, ':t')
                                let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                              else
                                let fname = ''
                                let sorted = g:tagbar_sort
                              endif
                              let sortstr = sorted ? 'Name' : 'Order'
                            
                              let flags = []
                              let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
                              let flags += g:tagbar_autoclose ? ['C'] : []
                              let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
                              let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
                              if exists('g:tagbar_status_func')
                                let args = [in_tagbar, sortstr, fname, flags]
                                let &l:statusline = call(g:tagbar_status_func, args)
                              else
                                let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                let flagstr = join(flags, '')
                                if flagstr !=# ''
                                  let flagstr = '[' . flagstr . '] '
                                endif
                                let text = colour . '[' . sortstr . '] ' . flagstr . fname
                                let &l:statusline = text
                              endif
                            
                              if !in_tagbar
                                call s:goto_win(pprevwinnr, 1)
                                call s:goto_win(prevwinnr, 1)
                              endif

FUNCTION  BookmarkLoad()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:220
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let supports_confirm = has("dialog_con") || has("dialog_gui")
                              let has_bookmarks = bm#total_count() ># 0
                              let confirmed = 1
                              if (supports_confirm && has_bookmarks && !a:silent)
                                let confirmed = confirm("Do you want to override your ". bm#total_count() ." bookmarks?", "&Yes\n&No")
                              endif
                              if (confirmed ==# 1)
                                call s:remove_all_bookmarks()
                                try
                                  let data = readfile(a:target_file)
                                  let new_entries = bm#deserialize(data)
                                  if !a:startup
                                    for entry in new_entries
                                      call bm_sign#add_at(entry['file'], entry['sign_idx'], entry['line_nr'], entry['annotation'] !=# "")
                                    endfor
                                    if (!a:silent)
                                      echo "Bookmarks loaded"
                                    endif
                                    return 1
                                  endif
                                catch
                                  if (!a:startup && !a:silent)
                                    echo "Failed to load/parse file"
                                  endif
                                  return 0
                                endtry
                              endif

FUNCTION  <SNR>324_get_context()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:603
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let base_filetype = empty(a:filetype) ? 'nothing' : a:filetype
                              let context_filetypes = get(a:context_filetypes, base_filetype, [])
                              if empty(context_filetypes)
                                return s:null_context
                              endif
                            
                              let pos = [line('.'), col('.')]
                            
                              for context in context_filetypes
                                if has_key(context, 'synname_pattern')
                                  for id in synstack(line('.'), col('.'))
                                    let synname = synIDattr(id, 'name')
                                    if synname =~# context.synname_pattern
                                      return {'filetype' : context.filetype, 'range': s:null_range, 'synname': synname}
                                    endif
                                  endfor
                                  continue
                                endif
                            
                                let range = s:search_range(context.start, context.end)
                            
                                " Set cursor position
                                let start = range[0]
                                let end   = [range[1][0], (mode() ==# 'i') ? range[1][1]+1 : range[1][1]]
                            
                                " start <= pos && pos <= end
                                " search_range[0] <= start && start <= search_range[1]
                                " search_range[0] <= end   && end   <= search_range[1]
                                if range != s:null_range  && s:is_in(start, end, pos)  && s:is_in(a:search_range[0], a:search_range[1], range[0])  && s:is_in(a:search_range[0], a:search_range[1], range[1])
                                  let context_filetype = context.filetype
                                  if context.filetype =~# '\\\@>\d'
                                    let stopline_back = s:stopline_back()
                                    let lines = getline( searchpos(context.start, 'nbW', stopline_back)[0], line('.') )
                                    let match_list = matchlist(join(lines, "\n"), context.start)
                                    let context_filetype = s:replace_submatch(context.filetype, match_list)
                                  endif
                                  return {'filetype' : context_filetype, 'range' : range}
                                endif
                              endfor
                            
                              return s:null_context

FUNCTION  neomake#_get_s()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:39
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:

FUNCTION  <SNR>349_get()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\state.vim:13
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
    1              0.000000     endif
                            
    1              0.000001     return t:tagbar_state

FUNCTION  neomake#utils#get_config_fts()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:181
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002     let delim = a:0 ? a:1 : '_'
    1              0.000002     let cache_key = a:ft . delim
    1              0.000003     if !has_key(s:cache_config_fts, cache_key)
                                    let r = []
                                    let fts = split(a:ft, '\.')
                                    for ft in fts
                                        call add(r, ft)
                                        let super_ft = neomake#utils#GetSupersetOf(ft)
                                        while !empty(super_ft)
                                            if index(fts, super_ft) == -1
                                                call add(r, super_ft)
                                            endif
                                            let super_ft = neomake#utils#GetSupersetOf(super_ft)
                                        endwhile
                                    endfor
                                    if len(fts) > 1
                                        call insert(r, a:ft, 0)
                                    endif
                                    let s:cache_config_fts[cache_key] = map(r, 'neomake#utils#get_ft_confname(v:val, delim)')
    1              0.000000     endif
    1              0.000002     return s:cache_config_fts[cache_key]

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:21
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   let ggvars = getbufvar(a:buffer, 'gitgutter')
    1              0.000003   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
    1              0.000001     return ggvars[a:varname]
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  <SNR>460_check_buffer()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\include.vim:50
Called 1 time
Total time:   0.016523
 Self time:   0.014215

count  total (s)   self (s)
    1              0.000004   let bufnr = (a:bufnr == '') ? bufnr('%') : a:bufnr
    1              0.000200   let filename = fnamemodify(bufname(bufnr), ':p')
                            
    1              0.000004   if !has_key(s:include_info, bufnr)
                                " Initialize.
                                let s:include_info[bufnr] = { 'include_files' : [], 'lines' : [], 'async_files' : {}, }
    1              0.000000   endif
                            
    1              0.000002   let include_info = s:include_info[bufnr]
                            
    1              0.000019   if a:is_force || include_info.lines !=# getbufline(bufnr, 1, 100)
    1              0.000013     let include_info.lines = getbufline(bufnr, 1, 100)
                            
                                " Check include files contained bufname.
    1   0.002257   0.000020     let include_files = s:get_buffer_include_files(bufnr)
                            
                                " Check include files from function.
    1              0.000004     let filetype = getbufvar(a:bufnr, '&filetype')
    1   0.000053   0.000013     let function = neoinclude#get_function(filetype)
    1              0.000002     if function != '' && getbufvar(bufnr, '&buftype') !~ 'nofile'
                                  let path = neoinclude#get_path(a:bufnr, filetype)
                                  let include_files += call(function, [getbufline(bufnr, 1, (a:is_force ? '$' : 1000)), path])
    1              0.000000     endif
                            
    1              0.000124     if getbufvar(bufnr, '&buftype') !~ 'nofile' && filereadable(filename)
    1              0.000005       call add(include_files, filename)
    1              0.000001     endif
    1   0.000034   0.000019     let include_info.include_files = neoinclude#util#uniq(include_files)
    1              0.000000   endif
                            
    1              0.000003   let filetype = getbufvar(bufnr, '&filetype')
    1              0.000001   if filetype == ''
                                let filetype = 'nothing'
    1              0.000000   endif
                            
    1   0.000053   0.000036   let ctags = neoinclude#util#get_buffer_config(filetype, 'b:neoinclude_ctags_commands', g:neoinclude#ctags_commands, g:neoinclude#_ctags_commands, '')
                            
    1              0.013676   if g:neoinclude#max_processes <= 0 || !executable(ctags)
                                return
    1              0.000001   endif
                            
    2              0.000008   for filename in include_info.include_files
    1              0.000007     if (a:is_force || !has_key(include_info.async_files, filename)) && !has_key(s:include_cache, filename)
                                  if !a:is_force && has_key(s:async_include_cache, filename) && len(s:async_include_cache[filename])            >= g:neoinclude#max_processes
                                    break
                                  endif
                            
                                  let s:async_include_cache[filename] = s:initialize_include(filename, filetype, ctags, a:is_force)
                                  let include_info.async_files[filename] = 1
    1              0.000001     endif
    2              0.000002   endfor

FUNCTION  deoplete#init#_prev_completion()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\init.vim:270
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'linenr': -1, 'candidates': [], 'complete_position': -1, 'time': reltime(), }

FUNCTION  matchup#pos#get_cursor()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\pos.vim:17
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return getcurpos()

FUNCTION  <SNR>50_check_len()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:170
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let len = 0
                              for item in a:items
                                let len += item.len
                              endfor
                              return len > &columns - 25

FUNCTION  neomake#makers#ft#markdown#markdownlint()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\makers\ft\markdown.vim:29
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return { 'errorformat': '%f:%l %m,%f: %l: %m' }

FUNCTION  bm#deserialize()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:178
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                exec join(a:data, " | ")
                                let ses = l:bm_sessions["default"]
                                let result = []
                                for file in keys(ses)
                                  for bm in ses[file]
                                    let annotation = has_key(bm, 'annotation') ? bm['annotation'] : ''
                                     call add(result,  extend( copy( bm#add_bookmark(file, bm['sign_idx'], bm['line_nr'], bm['content'], annotation) ), {'file': file} ))
                                  endfor
                                endfor
                                return result

FUNCTION  <SNR>16_circled_num()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\messletters.vim:33
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " https://www.unicode.org/charts/beta/nameslist/n_2460.html
                              if a:type == 0
                                if a:num == 0
                                  return nr2char(9471)
                                elseif index(range(1,10), a:num) != -1
                                  return nr2char(10102 + a:num - 1)
                                elseif index(range(11, 20), a:num)
                                  return nr2char(9451 + a:num - 11)
                                else
                                  return ''
                                endif
                              elseif a:type == 1
                                if index(range(20), a:num) != -1
                                  if a:num == 0
                                    return nr2char(9450)
                                  else
                                    return nr2char(9311 + a:num)
                                  endif
                                else
                                  return ''
                                endif
                              elseif a:type == 2
                                if index(range(1, 10), a:num) != -1
                                  return nr2char(9461 + a:num - 1)
                                else
                                  return ''
                                endif
                              elseif a:type == 3
                                return a:num
                              endif

FUNCTION  context_filetype#get_filetype()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:37
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let base_filetype = get(a:, 1, &filetype)
                              return context_filetype#get(base_filetype).filetype

FUNCTION  neoinclude#util#uniq()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:26
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000003   let dict = {}
    3              0.000004   for item in a:list
    1              0.000002     if !has_key(dict, item)
    1              0.000002       let dict[item] = item
    1              0.000000     endif
    3              0.000002   endfor
                            
    2              0.000003   return values(dict)

FUNCTION  <SNR>250_set_up_auto_save()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:524
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:bookmark_auto_save ==# 1 || g:bookmark_manage_per_buffer ==# 1
                                call s:startup_load_bookmarks(a:file)
                                let g:bm_current_file = a:file
                                augroup bm_auto_save
                                  autocmd!
                                  autocmd BufWinEnter * call s:add_missing_signs(expand('<afile>:p'))
                                  autocmd BufLeave,VimLeave,BufReadPre * call s:auto_save()
                                augroup END
                              endif

FUNCTION  <SNR>254_winshell()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:68
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  neoinclude#set_filetype_paths()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:175
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003   if a:filetype ==# 'python' && !has_key(g:neoinclude#paths, 'python')
                                " Initialize python path pattern.
                                if executable('python3')
                                  call s:set_python_paths('python3')
                                elseif executable('python')
                                  call s:set_python_paths('python')
                                endif
    1              0.000003   elseif a:filetype ==# 'cpp' && !has_key(g:neoinclude#paths, 'cpp') && isdirectory('/usr/include/c++')
                                call s:set_cpp_paths(a:bufnr)
    1              0.000000   endif

FUNCTION  <SNR>460_initialize_include()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\include.vim:189
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Initialize include list from tags.
                              let tags_file_name = tempname()
                              let args = neoinclude#util#get_buffer_config(a:filetype, 'b:neoinclude_ctags_arguments', g:neoinclude#ctags_arguments, g:neoinclude#_ctags_arguments, '')
                              if a:ctags == 'jsctags'
                                let command = printf('%s ''%s'' %s >''%s''', a:ctags, a:filename, args, tags_file_name)
                              elseif has('win32') || has('win64')
                                let filename = neoinclude#util#substitute_path_separator(a:filename)
                                let command = printf('%s -f "%s" %s "%s" ', a:ctags, tags_file_name, args, filename)
                              else
                                let command = printf('%s -f ''%s'' 2>/dev/null %s ''%s''', a:ctags, tags_file_name, args, a:filename)
                              endif
                            
                              if a:is_force
                                call neoinclude#util#system(command)
                              else
                                call neoinclude#util#async_system(command)
                              endif
                            
                              return { 'filename' : a:filename, 'cachename' : tags_file_name, }

FUNCTION  <SNR>372_DeleteExistingToc()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:423
Called 1 time
Total time:   0.000292
 Self time:   0.000269

count  total (s)   self (s)
    1              0.000002   let l:winview = winsaveview()
                            
    1              0.000015   keepjumps normal! gg0
                            
    1   0.000032   0.000019   let l:markdownStyle = <SID>GetMarkdownStyleInModeline()
                            
    1              0.000001   let l:isModeline = 0
                            
    1              0.000004   if index(s:supportMarkdownStyles, l:markdownStyle) != -1
                                let l:isModeline = 1
    1              0.000000   endif
                            
    1   0.000022   0.000016   let l:tocBeginPattern = <SID>GetBeginFencePattern(l:isModeline)
    1   0.000017   0.000015   let l:tocEndPattern = <SID>GetEndFencePattern()
                            
    1              0.000001   let l:beginLineNumber = -1
    1              0.000001   let l:endLineNumber= -1
                            
    1              0.000014   if search(l:tocBeginPattern, "Wc") != 0
    1              0.000002     let l:beginLine = getline(".")
    1              0.000002     let l:beginLineNumber = line(".")
                            
    1              0.000007     if search(l:tocEndPattern, "W") != 0
    1              0.000001       if l:isModeline == 0
    1              0.000010         let l:markdownStyle = matchlist(l:beginLine, l:tocBeginPattern)[1]
    1              0.000000       endif
                            
    1              0.000001       let l:doDelete = 0
    1              0.000002       if index(s:supportMarkdownStyles, l:markdownStyle) == -1
                                    if l:markdownStyle ==# "" && index(s:supportMarkdownStyles, g:vmt_fence_hidden_markdown_style) != -1
                                      let l:markdownStyle = g:vmt_fence_hidden_markdown_style
                                      let l:isModeline = 1
                                      let l:doDelete = 1
                                    else
                                      let l:markdownStyle = "Unknown"
                                    endif
    1              0.000000       else
    1              0.000001         let l:doDelete = 1
    1              0.000000       endif
                            
    1              0.000001       if l:doDelete == 1
    1              0.000001         let l:endLineNumber = line(".")
    1              0.000126         silent execute l:beginLineNumber. "," . l:endLineNumber. "delete_"
    1              0.000001         end
                                  else
                                    let l:markdownStyle = ""
                                    echom "Cannot find toc end fence"
    1              0.000000       endif
                                else
                                  let l:markdownStyle = ""
                                  echom "Cannot find toc begin fence"
    1              0.000000     endif
                            
    1              0.000003     call winrestview(l:winview)
                            
    1              0.000003     return [l:markdownStyle, l:beginLineNumber, l:endLineNumber, l:isModeline]

FUNCTION  <SNR>308_setup_path()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter.vim:156
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  defx#util#has_yarp()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:216
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008   return !has('nvim')

FUNCTION  SpaceVim#layers#isLoaded()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers.vim:164
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   return index(s:enabled_layers, a:layer) != -1

FUNCTION  defx#start()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx.vim:11
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let prev_winid = win_getid()
                            
                              call defx#initialize()
                              let context = defx#init#_context(a:user_context)
                              let paths = map(a:paths, "[v:val[0], fnamemodify(v:val[1], ':p')]")
                            
                              call defx#util#rpcrequest('_defx_start', [paths, context], v:false)
                            
                              if context['search'] !=# ''
                                call defx#call_action('search', [context['search']])
                              endif
                            
                              if !context['focus']
                                " Restore the window
                                call win_gotoid(prev_winid)
                              endif

FUNCTION  <SNR>344_getTagsByName()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\fileinfo.vim:85
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return get(self._tagdict, a:tagname, [])

FUNCTION  neoinclude#util#get_context_filetype()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:89
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " context_filetype.vim installation check.
                              if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
                              return s:exists_context_filetype ? context_filetype#get_filetype() : &filetype

FUNCTION  neoinclude#get_pattern()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:201
Called 1 time
Total time:   0.000041
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000040   0.000023   return neoinclude#util#get_buffer_config(   a:filetype, 'b:neoinclude_patterns',   g:neoinclude#patterns, g:neoinclude#_patterns,   getbufvar(a:bufnr, '&include'))

FUNCTION  <SNR>372_UpdateToc()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:382
Called 1 time
Total time:   0.001992
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000004   let l:winview = winsaveview()
                            
    1              0.000002   let l:totalLineNum = line("$")
                            
    1   0.000311   0.000019   let [l:markdownStyle, l:beginLineNumber, l:endLineNumber, l:isModeline] = <SID>DeleteExistingToc()
                            
    1              0.000001   if l:markdownStyle ==# ""
                                echom "Cannot find existing toc"
    1              0.000001   elseif l:markdownStyle ==# "Unknown"
                                echom "Find unsupported style toc"
    1              0.000000   else
    1              0.000002     let l:isFirstLine = (l:beginLineNumber == 1)
    1              0.000001     if l:beginLineNumber > 1
    1              0.000002       let l:beginLineNumber -= 1
    1              0.000000     endif
                            
    1              0.000001     if l:isFirstLine != 0
                                  call cursor(l:beginLineNumber, 1)
                                  put! =''
    1              0.000000     endif
                            
    1              0.000002     call cursor(l:beginLineNumber, 1)
    1   0.001643   0.000016     call <SID>GenTocInner(l:markdownStyle, l:isModeline)
                            
    1              0.000001     if l:isFirstLine != 0
                                  call cursor(l:beginLineNumber, 1)
                                  delete _
    1              0.000000     endif
                            
                                " fix line number to avoid shake
    1              0.000002     if l:winview['lnum'] > l:endLineNumber
    1              0.000002       let l:diff = line("$") - l:totalLineNum
    1              0.000002       let l:winview['lnum'] += l:diff
    1              0.000001       let l:winview['topline'] += l:diff
    1              0.000000     endif
    1              0.000000   endif
                            
    1              0.000002   call winrestview(l:winview)

FUNCTION  bm#all_files()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:148
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return keys(g:line_map)

FUNCTION  neoinclude#util#is_mac()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:22
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:is_mac

FUNCTION  <SNR>303_ProcessTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1570
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:is_split
                                let taginfo = tagbar#prototypes#splittag#new(a:name)
                              else
                                let taginfo = tagbar#prototypes#normaltag#new(a:name)
                              endif
                            
                              let taginfo.file    = a:filename
                              let taginfo.pattern = a:pattern
                              call extend(taginfo.fields, a:fields)
                            
                              " Needed for jsctags
                              if has_key(taginfo.fields, 'lineno')
                                let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                              endif
                              " Do some sanity checking in case ctags reports invalid line numbers
                              if taginfo.fields.line < 0
                                let taginfo.fields.line = 0
                              endif
                            
                              " Make sure our 'end' is valid
                              if taginfo.fields.end < taginfo.fields.line
                                if a:typeinfo.getKind(taginfo.fields.kind).stl
                                  " the config indicates this is a scoped kind due to 'stl', but we
                                  " don't have scope vars, assume scope goes to end of file. This
                                  " can also be the case for exhuberant ctags which doesn't support
                                  " the --fields=e option.
                                  " When we call the GetNearbyTag(), it will look up for the nearest
                                  " tag, so if we have multiples that have scope to the end of the
                                  " file it will still only grab the first one above the current line
                                  let taginfo.fields.end = line('$')
                                else
                                  let taginfo.fields.end = taginfo.fields.line
                                endif
                              endif
                            
                              if !has_key(taginfo.fields, 'kind')
                                call tagbar#log#debug( "Warning: No 'kind' field found for tag " . a:name[0] . '!')
                                if index(s:warnings.type, a:typeinfo.ftype) == -1
                                  call s:warning("No 'kind' field found for tag " . a:name[0] . '!' . " Please read the last section of ':help tagbar-extend'.")
                                  call add(s:warnings.type, a:typeinfo.ftype)
                                endif
                                return
                              endif
                            
                              let taginfo.fileinfo = a:fileinfo
                              let taginfo.typeinfo = a:typeinfo
                            
                              let a:fileinfo.fline[taginfo.fields.line] = taginfo
                            
                              if has_key(taginfo.fields, 'typeref')
                                let typeref = taginfo.fields.typeref
                                let delimit = stridx(typeref, ':')
                                let key = strpart(typeref, 0, delimit)
                                if key ==# 'typename'
                                  let taginfo.data_type = substitute(strpart(typeref, delimit + 1), '\t', '', 'g')
                                else
                                  let taginfo.data_type = key
                                endif
                              endif
                            
                              " If this filetype doesn't have any scope information then we can stop
                              " here after adding the tag to the list
                              if !has_key(a:typeinfo, 'scope2kind')
                                call a:fileinfo.addTag(taginfo)
                                return
                              endif
                            
                            
                              " Make some information easier accessible
                              for scope in keys(a:typeinfo.scope2kind)
                                if has_key(taginfo.fields, scope)
                                  let taginfo.scope = scope
                                  let taginfo.path  = taginfo.fields[scope]
                            
                                  let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
                                  break
                                endif
                              endfor
                              let pathlist = split(taginfo.path, '\V' . escape(a:typeinfo.sro, '\'))
                              let taginfo.depth = len(pathlist)
                            
                              " Needed for folding
                              try
                                call taginfo.initFoldState(s:known_files)
                              catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                " The tag has a 'kind' that doesn't exist in the type definition
                                call tagbar#log#debug('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                if index(s:warnings.type, a:typeinfo.ftype) == -1
                                  call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                  call add(s:warnings.type, a:typeinfo.ftype)
                                endif
                                return
                              endtry
                            
                              call s:add_tag_recursive({}, taginfo, pathlist)

FUNCTION  <SNR>303_GetNearbyTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3186
Called 1 time
Total time:   0.000649
 Self time:   0.000591

count  total (s)   self (s)
    1              0.000001   if s:nearby_disabled
                                return {}
    1              0.000000   endif
                            
    1   0.000056   0.000021   let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
    1              0.000001   if empty(fileinfo)
                                return {}
    1              0.000000   endif
                            
    1              0.000002   let curline = a:0 > 0 ? a:1 : line('.')
    1              0.000001   let direction = a:0 > 1 ? a:2 : -1
    1              0.000001   let ignore_curline = a:0 > 2 ? a:3 : 0
                            
    1              0.000001   let typeinfo = fileinfo.typeinfo
    1              0.000001   let tag = {}
                            
    1              0.000001   if direction < 0
    1              0.000001     let endline = 1
    1              0.000001     let increment = -1
                              else
                                let endline = line('$')
                                let increment = 1
    1              0.000000   endif
                            
                              " If a tag appears in a file more than once (for example namespaces in
                              " C++) only one of them has a 'tline' entry and can thus be highlighted.
                              " The only way to solve this would be to go over the whole tag list again,
                              " making everything slower. Since this should be a rare occurence and
                              " highlighting isn't /that/ important ignore it for now.
   43              0.000026   for line in range(curline, endline, increment)
   42              0.000053     if has_key(fileinfo.fline, line)
    5              0.000007       let curtag = fileinfo.fline[line]
    5   0.000082   0.000060       if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
                                    let tag = curtag
                                    break
    5              0.000017       elseif a:request ==# 'scoped-stl' && typeinfo.getKind(curtag.fields.kind).stl && curtag.fields.line <= curline && curline <= curtag.fields.end
                                    let tag = curtag
                                    break
    5              0.000009       elseif a:request ==# 'nearest' || (line == curline && ignore_curline == 0)
                                    let tag = curtag
                                    break
    5              0.000001       endif
   42              0.000009     endif
   43              0.000012   endfor
                            
    1              0.000001   return tag

FUNCTION  SpaceVim#plugins#scrollbar#clear()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\scrollbar.vim:182
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:WIN.is_float(s:scrollbar_winid)
                                call s:FLOAT.win_close(s:scrollbar_winid, 1)
                              endif

FUNCTION  <SNR>126_get_setting()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:28
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return get(get(b:, 'neomake', {}), a:name, get(get(t:, 'neomake', {}), a:name, get(get(g:, 'neomake', {}), a:name, a:default)))

FUNCTION  neomake#GetEnabledMakers()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:932
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let file_mode = a:0
                                if !file_mode
                                    " If we have no filetype, use the global default makers.
                                    " This variable is also used for project jobs, so it has no
                                    " buffer local ('b:') counterpart for now.
                                    let enabled_makers = copy(get(g:, 'neomake_enabled_makers', []))
                                    if empty(enabled_makers)
                                        let makeprg_maker = s:get_makeprg_maker()
                                        if !empty(makeprg_maker)
                                            let makeprg_maker = neomake#GetMaker(makeprg_maker)
                                            let makeprg_maker.auto_enabled = 1
                                            let enabled_makers = [makeprg_maker]
                                        endif
                                    else
                                        call map(enabled_makers, "extend(neomake#GetMaker(v:val), {'auto_enabled': 0}, 'error')")
                                    endif
                                else
                                    let enabled_makers = []
                                    let bufnr = bufnr('%')
                                    let makers = neomake#utils#GetSetting('enabled_makers', {}, s:unset_list, a:1, bufnr)
                                    if makers is# s:unset_list
                                        let auto_enabled = 1
                                        for config_ft in neomake#utils#get_config_fts(a:1)
                                            call neomake#utils#load_ft_makers(config_ft)
                                            let fnname = 'neomake#makers#ft#'.config_ft.'#EnabledMakers'
                                            if exists('*'.fnname)
                                                try
                                                    let makers = call(fnname, [])
                                                catch /^Vim(let):E119:/  " Not enough arguments for function
                                                    let makers = call(fnname, [{'file_mode': file_mode, 'bufnr': bufnr}])
                                                endtry
                                                break
                                            endif
                                        endfor
                                    else
                                        let auto_enabled = 0
                                    endif
                                    let enabled_makers = neomake#map_makers(makers, a:1, auto_enabled)
                                endif
                                return enabled_makers

FUNCTION  <SNR>40_active()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:643
Called 1 time
Total time:   0.002043
 Self time:   0.000298

count  total (s)   self (s)
    1              0.000001   let lsec = []
   10              0.000012   for section in g:spacevim_statusline_left
    9              0.000018     if has_key(s:registed_sections, section)
    9   0.000524   0.000128       call add(lsec, call(s:registed_sections[section], []))
    9              0.000034     endif
   10              0.000004   endfor
    1              0.000001   let rsec = []
    3              0.000004   for section in g:spacevim_statusline_right
    2              0.000003     if has_key(s:registed_sections, section)
    2   0.000082   0.000034       call add(rsec, call(s:registed_sections[section], []))
    2              0.000001     endif
    3              0.000001   endfor
    1   0.000016   0.000010   let fname = s:buffer_name()
    1   0.000013   0.000011   let tag = s:current_tag()
    1   0.001317   0.000023   return s:STATUSLINE.build(lsec, rsec, s:lsep, s:rsep, fname, tag, 'SpaceVim_statusline_a', 'SpaceVim_statusline_b', 'SpaceVim_statusline_c', 'SpaceVim_statusline_z', &laststatus ==# 3 ? &columns : winwidth(winnr()))

FUNCTION  <SNR>454_on_update_exit()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\ctags.vim:104
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " @bug on exit function is not called when failed
                              " C:\Users\wsdjeg\.SpaceVim>C:\Users\wsdjeg\.SpaceVim\bundle\phpcomplete.vim\bin\ctags.exe -R -o C:/Users/wsdjeg/.cache/SpaceVim/tags/C__Users_wsd
                              " jeg__SpaceVim_/tags C:\Users\wsdjeg\.SpaceVim
                              "
                              " C:\Users\wsdjeg\.SpaceVim>echo %ERRORLEVEL%
                              " -1073741819
                              " https://github.com/neovim/neovim/issues/20856
                              if a:data != 0
                                call s:LOGGER.warn('failed to update gtags, exit data: ' . a:data)
                              else
                                call s:LOGGER.info('ctags database updated successfully')
                              endif

FUNCTION  deoplete#util#get_next_input()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:40
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>344_sortTags()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\fileinfo.vim:129
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if get(a:compare_typeinfo, 'sort', g:tagbar_sort)
                                    call tagbar#sorting#sort(self._taglist, 'kind', a:compare_typeinfo)
                                else
                                    call tagbar#sorting#sort(self._taglist, 'line', a:compare_typeinfo)
                                endif

FUNCTION  deoplete#util#uniq()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:86
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let list = map(copy(a:list), { _, val -> [val, val] })
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, { _, val -> val[0] })

FUNCTION  27()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\file.vim:179
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file = fnamemodify(a:path, ':t')
                              if has_key(s:file_node_exact_matches, file)
                                return s:file_node_exact_matches[file]
                              endif
                              for [k, v]  in items(s:file_node_pattern_matches)
                                if match(file, k) != -1
                                  return v
                                endif
                              endfor
                              let ext = fnamemodify(file, ':e')
                              if has_key(g:spacevim_filetype_icons, ext)
                                return g:spacevim_filetype_icons[ext]
                              elseif has_key(s:file_node_extensions, ext)
                                return s:file_node_extensions[ext]
                              endif
                              return ''
                            

FUNCTION  SpaceVim#layers#core#statusline#winnr()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:150
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:MESSLETTERS.circled_num(a:id, g:spacevim_windows_index_type)

FUNCTION  33()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\file.vim:254
Called 4 times
Total time:   0.000633
 Self time:   0.000633

count  total (s)   self (s)
    4              0.000006   if empty(a:path)
                                return ''
    4              0.000002   endif
    4              0.000007   let mod = a:0 > 0 ? a:1 : ':p'
    4              0.000340   let path = fnamemodify(a:path, mod . ':gs?[\\/]?/?')
    4              0.000246   if isdirectory(path) && path[-1:] !=# '/'
                                return path . '/'
    4              0.000008   elseif a:path[-1:] ==# '/' && path[-1:] !=# '/'
                                return path . '/'
    4              0.000002   else
    4              0.000003     return path
                              endif

FUNCTION  34()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\file.vim:269
Called 2 times
Total time:   0.000317
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000007   let sep = get(a:000, 0, '_')
    2   0.000308   0.000030   return substitute(self.unify_path(a:path), '[\\/:;.]', sep, 'g')

FUNCTION  35()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\file.vim:280
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let old_suffixesadd = &suffixesadd
                              let &suffixesadd = ''
                              let l:count = get(a:000, 0, 0)
                            
                              if filereadable(a:where) && !isdirectory(a:where)
                                let path = fnamemodify(a:where, ':h')
                              else
                                let path = a:where
                              endif
                              if l:count > 0
                                let file = findfile(a:what, escape(path, ' ') . ';', l:count)
                              elseif a:0 ==# 0
                                let file = findfile(a:what, escape(path, ' ') . ';')
                              elseif l:count ==# 0
                                let file = findfile(a:what, escape(path, ' ') . ';', -1)
                              else
                                let file = get(findfile(a:what, escape(path, ' ') . ';', -1), l:count, '')
                              endif
                              let &suffixesadd = old_suffixesadd
                              return file

FUNCTION  <SNR>372_GetHeadingLines()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:118
Called 1 time
Total time:   0.000890
 Self time:   0.000346

count  total (s)   self (s)
    1              0.000003   let l:winview = winsaveview()
    1              0.000001   let l:headingLines = []
    1   0.000493   0.000013   let l:codeSections = <SID>GetCodeSections()
                            
    1              0.000001   let l:flags = "W"
    1              0.000001   if g:vmt_include_headings_before == 1
                                keepjumps normal! gg0
                                let l:flags = "Wc"
    1              0.000000   endif
                            
    1   0.000016   0.000015   let l:headingLineRegex = <SID>HeadingLineRegex()
                            
    5              0.000168   while search(l:headingLineRegex, l:flags) != 0
    4              0.000006     let l:line = getline(".")
    4              0.000005     let l:lineNum = line(".")
    4   0.000124   0.000062     if <SID>IsLineInCodeSections(l:codeSections, l:lineNum) == 0
                                  " === compatible with Setext Style headings
    4              0.000007       let l:nextLine = getline(l:lineNum + 1)
    4              0.000012       if matchstr(l:nextLine, '\v^\=+$') != ""
                                    let l:line = "# " . l:line
    4              0.000010       elseif matchstr(l:nextLine, '\v^\-+$') != ""
                                    let l:line = "## " . l:line
    4              0.000001       endif
                                  " ===
                            
    4              0.000007       call add(l:headingLines, l:line)
    4              0.000001     endif
    4              0.000003     let l:flags = "W"
    5              0.000002   endwhile
                            
    1              0.000002   call winrestview(l:winview)
                            
    1              0.000001   return l:headingLines

FUNCTION  <SNR>135_enable_cursorline()
    Defined: ~\.SpaceVim\autoload\SpaceVim\autocmds.vim:74
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:_spacevim_cursorline_flag == -1
                                setl cursorline
                              endif

FUNCTION  defx#util#truncate_skipping()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:293
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let width = strwidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - strwidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                              return s:truncate(ret, a:max)

FUNCTION  <SNR>329_parse_args()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\pos.vim:112
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
                              if len(a:args) > 1
                                return s:parse_args([a:args])
                              elseif len(a:args) == 1
                                if type(a:args[0]) == type({})
                                  return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
                                else
                                  if len(a:args[0]) == 2
                                    return a:args[0]
                                  else
                                    return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  47()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\signatures.vim:53
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call nvim_buf_clear_namespace(0, self._hi_namespace, 0, -1)

FUNCTION  neomake#makers#ft#markdown#EnabledMakers()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\makers\ft\markdown.vim:5
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let makers = executable('mdl') ? ['mdl'] : ['markdownlint']
                                if executable('vale') | let makers += ['vale'] | endif
                                return makers + neomake#makers#ft#text#EnabledMakers()

FUNCTION  <SNR>122_remove_quote_pairs()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:112
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " remove leading/ending quote pairs
                              let s = a:s
                              if s[0] ==# '"' && s[len(s) - 1] ==# '"'
                                let s = s[1: len(s) - 2]
                              elseif s[0] ==# "'" && s[len(s) - 1] ==# "'"
                                let s = s[1: len(s) - 2]
                              else
                                let s = substitute(a:s, '\\\(.\)', "\\1", 'g')
                              endif
                              return s

FUNCTION  <SNR>40_search_count()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:323
Called 1 time
Total time:   0.000018
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000018   0.000015   return SpaceVim#plugins#searcher#count()

FUNCTION  context_filetype#get()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:26
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let base_filetype = get(a:, 1, &filetype)
                              let filetypes = context_filetype#filetypes()
                              let context = s:get_nest(base_filetype, filetypes)
                              if context.range == s:null_range && !has_key(context, 'synname')
                                let context.filetype = base_filetype
                              endif
                              return context

FUNCTION  neomake#statusline#LoclistCounts()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\statusline.vim:116
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002     let buf = a:0 ? a:1 : bufnr('%')
    1              0.000001     if buf is# 'all'
                                    return s:counts
    1              0.000000     endif
    1              0.000003     return get(s:counts, buf, {})

FUNCTION  neosnippet#helpers#get_completion_snippets()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\helpers.vim:55
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return values(filter(neosnippet#helpers#get_snippets(), "!get(v:val.options, 'oneshot', 0)"))

FUNCTION  bm#all_bookmarks_by_line()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:116
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(g:line_map, a:file)
                                return {}
                              endif
                              return g:line_map[a:file]

FUNCTION  <SNR>236_GetBestPath()
    Defined: ~\.SpaceVim\bundle\cscope.vim\autoload\cscope.vim:261
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004   let f = a:dir
    1              0.000002   let bestDir = ''
    1              0.000004   for d in keys(s:dbs)
                                if stridx(f, d) == 0 && len(d) > len(bestDir)
                                  return d
                                endif
    1              0.000001   endfor
    1              0.000001   return ''

FUNCTION  76()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\buffer.vim:58
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('patch-8.1.1924')
                                return call('bufnr', a:000)
                              else
                                if a:0 ==# 0
                                  return bufnr('%')
                                else
                                  return call('bufnr', a:000)
                                endif
                              endif

FUNCTION  <SNR>324_file_range()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:500
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return [[1, 1], [line('$'), len(getline('$'))+1]]

FUNCTION  81()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\buffer.vim:144
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return filter(range(1, bufnr('$')), 'buflisted(v:val)')

FUNCTION  89()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\highlight.vim:23
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let id = hlID(a:name)
                              if id == 0
                                return { 'name' : '', 'ctermbg' : '', 'ctermfg' : '', 'bold' : '', 'italic' : '', 'reverse' : '', 'underline' : '', 'guibg' : '', 'guifg' : '', }
                              endif
                              let rst = { 'name' : synIDattr(id, 'name'), 'ctermbg' : synIDattr(id, 'bg', 'cterm'), 'ctermfg' : synIDattr(id, 'fg', 'cterm'), 'bold' : synIDattr(id, 'bold'), 'italic' : synIDattr(id, 'italic'), 'reverse' : synIDattr(id, 'reverse'), 'underline' : synIDattr(id, 'underline'), 'guibg' : tolower(synIDattr(id, 'bg#', 'gui')), 'guifg' : tolower(synIDattr(id, 'fg#', 'gui')), }
                              return rst

FUNCTION  neosnippet#variables#expand_stack()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\variables.vim:20
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if !exists('s:expand_stack')
                                let s:expand_stack = []
    1              0.000000   endif
                            
    1              0.000001   return s:expand_stack

FUNCTION  91()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\highlight.vim:65
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:info) || get(a:info, 'name', '') ==# ''
                                return
                              endif
                              exe 'hi clear ' . a:info.name
                              let cmd = 'hi! ' .  a:info.name
                              if !empty(a:info.ctermbg)
                                let cmd .= ' ctermbg=' . a:info.ctermbg
                              endif
                              if !empty(a:info.ctermfg)
                                let cmd .= ' ctermfg=' . a:info.ctermfg
                              endif
                              if !empty(a:info.guibg)
                                let cmd .= ' guibg=' . a:info.guibg
                              endif
                              if !empty(a:info.guifg)
                                let cmd .= ' guifg=' . a:info.guifg
                              endif
                              let style = []
                              for sty in ['bold', 'italic', 'underline', 'reverse']
                                if get(a:info, sty, '') ==# '1'
                                  call add(style, sty)
                                endif
                              endfor
                              if !empty(style)
                                let cmd .= ' gui=' . join(style, ',') . ' cterm=' . join(style, ',')
                              endif
                              try
                                silent! exe cmd
                              catch
                              endtry

FUNCTION  93()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\highlight.vim:114
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let hi_a = self.group2dict(a:a)
                              let hi_b = self.group2dict(a:b)
                              let hi_a_b = { 'name' : a:a . '_' . a:b, 'guibg' : hi_b.guibg, 'guifg' : hi_a.guibg, 'ctermbg' : hi_b.ctermbg, 'ctermfg' : hi_a.ctermbg, }
                              let hi_b_a = { 'name' : a:b . '_' . a:a, 'guibg' : hi_a.guibg, 'guifg' : hi_b.guibg, 'ctermbg' : hi_a.ctermbg, 'ctermfg' : hi_b.ctermbg, }
                              call self.hi(hi_a_b)
                              call self.hi(hi_b_a)

FUNCTION  <SNR>346_isSplitTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:64
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 0

FUNCTION  deoplete#init#_channel_initialized()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\init.vim:97
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  <SNR>372_GetHeadingLink()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:253
Called 4 times
Total time:   0.000204
 Self time:   0.000064

count  total (s)   self (s)
    4              0.000008   if a:markdownStyle ==# s:supportMarkdownStyles[s:GFM_STYLE_INDEX]
    4   0.000194   0.000054     return <SID>GetHeadingLinkGFM(a:headingName)
                              elseif a:markdownStyle ==# s:supportMarkdownStyles[s:REDCARPET_STYLE_INDEX]
                                return <SID>GetHeadingLinkRedcarpet(a:headingName)
                              elseif a:markdownStyle ==# s:supportMarkdownStyles[s:GITLAB_STYLE_INDEX]
                                return <SID>GetHeadingLinkGitLab(a:headingName)
                              elseif a:markdownStyle ==# s:supportMarkdownStyles[s:MARKED_STYLE_INDEX]
                                return <SID>GetHeadingLinkMarked(a:headingName)
                              endif

FUNCTION  dein#autoload#_source()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\autoload.vim:1
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let plugins = empty(a:000) ? values(g:dein#_plugins) : dein#util#_convert2list(a:1)
                              if empty(plugins)
                                return []
                              endif
                            
                              if type(plugins[0]) != v:t_dict
                                let plugins = map(dein#util#_convert2list(a:1),       { _, val -> get(g:dein#_plugins, val, {}) })
                              endif
                            
                              let rtps = dein#util#_split_rtp(&runtimepath)
                              let index = index(rtps, dein#util#_get_runtime_path())
                              if index < 0
                                return []
                              endif
                            
                              let sourced = []
                              for plugin in filter(plugins, { _, val -> !empty(val) && !val.sourced && val.rtp !=# ''             && (!has_key(v:val, 'if') || eval(v:val.if)) })
                                call s:source_plugin(rtps, index, plugin, sourced)
                              endfor
                            
                              let filetype_before = dein#util#_redir('autocmd FileType')
                              let &runtimepath = dein#util#_join_rtp(rtps, &runtimepath, '')
                            
                              call dein#call_hook('source', sourced)
                            
                              " Reload script files.
                              for plugin in sourced
                                for directory in map(filter( ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'], { _, val -> isdirectory(plugin.rtp . '/' . val) }), { _, val -> plugin.rtp . '/' . val })
                                  if directory =~# 'ftdetect'
                                    if !get(plugin, 'merge_ftdetect')
                                      execute 'augroup filetypedetect'
                                    endif
                                  endif
                                  let files = glob(directory . '/**/*.vim', v:true, v:true)
                                  if has('nvim')
                                    let files += glob(directory . '/**/*.lua', v:true, v:true)
                                  endif
                                  for file in files
                                    execute 'source' fnameescape(file)
                                  endfor
                                  if directory =~# 'ftdetect'
                                    execute 'augroup END'
                                  endif
                                endfor
                            
                                if !has('vim_starting')
                                  let augroup = get(plugin, 'augroup', plugin.normalized_name)
                                  let events = ['VimEnter', 'BufRead', 'BufEnter', 'BufWinEnter', 'WinEnter']
                                  if has('gui_running') && &term ==# 'builtin_gui'
                                    call add(events, 'GUIEnter')
                                  endif
                                  for event in events
                                    if exists('#'.augroup.'#'.event)
                                      silent execute 'doautocmd' augroup event
                                    endif
                                  endfor
                            
                                  " Register for lazy loaded denops plugin
                                  if isdirectory(plugin.rtp . '/denops')
                                    for name in filter(map(globpath(plugin.rtp, 'denops/*/main.ts', v:true, v:true), { _, val -> fnamemodify(val, ':h:t')}), { _, val -> !denops#plugin#is_loaded(val) })
                            
                                      if denops#server#status() ==# 'running'
                                        " Note: denops#plugin#register() may be failed
                                        silent! call denops#plugin#register(name, { 'mode': 'skip' })
                                      endif
                                      call denops#plugin#wait(name)
                                      redraw
                                    endfor
                                  endif
                                endif
                              endfor
                            
                              let filetype_after = dein#util#_redir('autocmd FileType')
                            
                              let is_reset = s:is_reset_ftplugin(sourced)
                              if is_reset
                                call s:reset_ftplugin()
                              endif
                            
                              if (is_reset || filetype_before !=# filetype_after) && &l:filetype !=# ''
                                " Recall FileType autocmd
                                let &l:filetype = &l:filetype
                              endif
                            
                              if !has('vim_starting')
                                call dein#call_hook('post_source', sourced)
                              endif
                            
                              return sourced

FUNCTION  matchup#perf#tic()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\perf.vim:15
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let s:time_start[a:context] = reltime()

FUNCTION  <SNR>425_IsMkdCode()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:21
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let name = synIDattr(synID(a:lnum, 1, 0), 'name')
                                return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')

FUNCTION  tagbar#state#set_current_file()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\state.vim:5
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:get().setCurrentFile(a:fileinfo)

FUNCTION  tagbar#currenttag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3934
Called 1 time
Total time:   0.000717
 Self time:   0.000050

count  total (s)   self (s)
                              " Indicate that the statusline functionality is being used. This prevents
                              " the CloseWindow() function from removing the autocommands.
    1              0.000002   let s:statusline_in_use = 1
                            
    1              0.000001   if a:0 >= 1
                                " also test for non-zero value for backwards compatibility
                                let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
                                let fullpath  = a:1 =~# 'f'
                                let prototype = a:1 =~# 'p'
                                if a:0 >= 2
                                  let search_method = a:2
                                else
                                  let search_method = g:tagbar_highlight_method
                                endif
    1              0.000000   else
    1              0.000001     let longsig   = 0
    1              0.000001     let fullpath  = 0
    1              0.000001     let prototype = 0
    1              0.000002     let search_method = g:tagbar_highlight_method
    1              0.000000   endif
                            
    1   0.000028   0.000010   if !s:Init(1)
                                return a:default
    1              0.000000   endif
                            
    1   0.000661   0.000013   let tag = s:GetNearbyTag(search_method, 1)
                            
    1              0.000001   if !empty(tag)
                                if prototype
                                  return tag.getPrototype(1)
                                else
                                  return printf(a:fmt, tag.str(longsig, fullpath))
                                endif
    1              0.000000   else
    1              0.000001     return a:default
                              endif

FUNCTION  <SNR>333_GetMakerForFiletype()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:734
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for config_ft in neomake#utils#get_config_fts(a:ft)
                                    call neomake#utils#load_ft_makers(config_ft)
                                    let f = 'neomake#makers#ft#'.config_ft.'#'.a:maker_name
                                    if exists('*'.f)
                                        let maker = call(f, [])
                                        return maker
                                    endif
                                endfor
                                return s:unset_dict

FUNCTION  <SNR>16_bubble_num()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\messletters.vim:14
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let list = []
                              call add(list,['➊', '➋', '➌', '➍', '➎', '➏', '➐', '➑', '➒', '➓'])
                              call add(list,['➀', '➁', '➂', '➃', '➄', '➅', '➆', '➇', '➈', '➉'])
                              call add(list,['⓵', '⓶', '⓷', '⓸', '⓹', '⓺', '⓻', '⓼', '⓽', '⓾'])
                              let n = ''
                              try
                                let n = list[a:type][a:num-1]
                              catch
                              endtry
                              return  n

FUNCTION  <SNR>372_GetIndentText()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:337
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000006   if !empty(g:vmt_list_indent_text)
    4              0.000003     return g:vmt_list_indent_text
                              endif
                              if &expandtab
                                return repeat(" ", &shiftwidth)
                              else
                                return "\t"
                              endif

FUNCTION  neoinclude#get_function()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:225
Called 1 time
Total time:   0.000039
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000038   0.000021   return neoinclude#util#get_buffer_config(   a:filetype, 'b:neoinclude_functions',   g:neoinclude#functions, g:neoinclude#_functions,   '')

FUNCTION  neomake#compat#getbufvar()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\compat.vim:10
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    return getbufvar(a:buf, a:key, a:def)

FUNCTION  neosnippet#variables#current_neosnippet()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\variables.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:neosnippet')
                                let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0, 'optional_tabstop' : 0,}
                              endif
                            
                              return b:neosnippet

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:112
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>40_buffer_name()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:362
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   if get(b:, '_spacevim_statusline_showbfname', 0) == 1 || g:spacevim_enable_statusline_bfpath
                                return  ' ' . bufname('%')
    1              0.000000   else
    1              0.000000     return ''
                              endif

FUNCTION  <SNR>460_get_buffer_include_files()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\include.vim:116
Called 1 time
Total time:   0.002237
 Self time:   0.000580

count  total (s)   self (s)
    1              0.000003   let filetype = getbufvar(a:bufnr, '&filetype')
    1              0.000001   if filetype == ''
                                return []
    1              0.000000   endif
                            
    1   0.000044   0.000030   call neoinclude#set_filetype_paths(a:bufnr, filetype)
                            
    1   0.000055   0.000014   let pattern = neoinclude#get_pattern(a:bufnr, filetype)
    1              0.000001   if pattern == ''
                                return []
    1              0.000000   endif
    1   0.000114   0.000047   let path = neoinclude#get_path(a:bufnr, filetype)
    1   0.000044   0.000012   let expr = neoinclude#get_expr(a:bufnr, filetype)
    1              0.000002   let suffixes = &l:suffixesadd
                            
                              " Change current directory.
    1              0.000177   let buffer_dir = fnamemodify(bufname(a:bufnr), ':p:h')
    1   0.000245   0.000015   let cwd_save = neoinclude#util#cd(buffer_dir)
                            
    1              0.000001   try
    1   0.001295   0.000031     let include_files = s:get_include_files(0, getbufline(a:bufnr, 1, 100), filetype, pattern, path, expr)
    1              0.000001   finally
    1              0.000002     if !empty(cwd_save)
    1              0.000206       execute cwd_save[0] fnameescape(cwd_save[1])
    1              0.000001     endif
                            
                                " Restore option.
    1              0.000008     let &l:suffixesadd = suffixes
    1              0.000001   endtry
                            
    1   0.000029   0.000018   return neoinclude#util#uniq(include_files)

FUNCTION  matchup#perf#timeout_start()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\perf.vim:84
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let s:timeout = a:timeout
                              let s:timeout_enabled = (a:timeout == 0) ? 0 : 1
                              let s:timeout_pulse_time = reltime()

FUNCTION  <SNR>345_str()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\normaltag.vim:56
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:full && self.path !=# ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
                                    let str = self.name
                                endif
                            
                                if has_key(self.fields, 'signature')
                                    if a:longsig
                                        let str .= self.fields.signature
                                    else
                                        let str .= '()'
                                    endif
                                endif
                            
                                return str

FUNCTION  <SNR>324_get_nest()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:665
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let context = s:get_context(a:filetype, a:context_filetypes, s:file_range())
                              return s:get_nest_impl(context.filetype, a:context_filetypes, context)

FUNCTION  <SNR>50_buffer_item()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:148
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let name = s:tabname(a:bufnr)
                              let tabnr = get(a:000, 0, -1)
                              if tabnr != -1
                                let tabname = gettabvar(tabnr, '_spacevim_tab_name', '')
                                let len = strlen(tabname) + 3
                              else
                                let tabname = ''
                                let len = strlen(name) + 3
                              endif
                              let item = { 'bufnr' : a:bufnr, 'len' :  len, 'bufname' : name, 'tabname' : tabname, 'tabnr' : tabnr, }
                              return item

FUNCTION  matchup#perf#toc()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\perf.vim:19
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:elapsed = s:reltimefloat(reltime(s:time_start[a:context]))
                            
                              let l:key = a:context.'#'.a:state
                              if has_key(g:matchup#perf#times, l:key)
                                if l:elapsed > g:matchup#perf#times[l:key].maximum
                                  let g:matchup#perf#times[l:key].maximum = l:elapsed
                                endif
                                let g:matchup#perf#times[l:key].last = l:elapsed
                                let g:matchup#perf#times[l:key].emavg = s:alpha*l:elapsed + (1-s:alpha)*g:matchup#perf#times[l:key].emavg
                              else
                                let g:matchup#perf#times[l:key] = { 'maximum' : l:elapsed, 'emavg'   : l:elapsed, 'last'    : l:elapsed,}
                              endif

FUNCTION  tagbar#prototypes#normaltag#new()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\normaltag.vim:10
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let newobj = tagbar#prototypes#basetag#new(a:name)
                            
                                let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
                                let newobj.strfmt = function(s:add_snr('s:strfmt'))
                                let newobj.str = function(s:add_snr('s:str'))
                                let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                                let newobj.getDataType = function(s:add_snr('s:getDataType'))
                            
                                return newobj

FUNCTION  <SNR>40_fileformat()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:162
Called 1 time
Total time:   0.000044
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001   if g:spacevim_statusline_unicode == 1
    1   0.000038   0.000014     let g:_spacevim_statusline_fileformat = s:SYSTEM.fileformat()
                              else
                                let g:_spacevim_statusline_fileformat = &ff
    1              0.000000   endif
    1              0.000002   return '%{" " . g:_spacevim_statusline_fileformat . " | " . (&fenc!=""?&fenc:&enc) . " "}'

FUNCTION  <SNR>250_remove_all_bookmarks()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:447
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let files = bm#all_files()
                              for file in files
                                let lines = bm#all_lines(file)
                                for line_nr in lines
                                  call s:bookmark_remove(file, line_nr)
                                endfor
                              endfor

FUNCTION  <SNR>312_internal_options()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\init.vim:127
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'cursor': line('.'), 'drives': [], 'prev_bufnr': bufnr('%'), 'prev_last_bufnr': bufnr('#'), 'prev_winid': win_getid(), 'visual_start': getpos("'<")[1], 'visual_end': getpos("'>")[1], }

FUNCTION  neomake#create_maker_object()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:808
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let [maker, ft, bufnr] = [a:maker, a:ft, bufnr('%')]
                            
                                " Create the maker object.
                                let l:GetEntries = neomake#utils#GetSetting('get_list_entries', maker, -1, ft, bufnr)
                                if GetEntries isnot# -1
                                    let maker = copy(maker)
                                    let maker.get_list_entries = GetEntries
                                else
                                    let maker = extend(copy(s:command_maker_base), copy(maker))
                                endif
                                if !has_key(maker, 'get_list_entries')
                                    " Set defaults for command/job based makers.
                                    let defaults = extend( copy(g:neomake#config#_defaults['maker_defaults']), neomake#config#get('maker_defaults'))
                                    call extend(defaults, { 'exe': maker.name, 'args': [], })
                                    if !has_key(maker, 'process_output') && !has_key(maker, 'process_json')
                                        call extend(defaults, { 'errorformat': &errorformat, })
                                    endif
                                    for [key, default] in items(defaults)
                                        let maker[key] = neomake#utils#GetSetting(key, {'name': maker.name}, get(maker, key, default), ft, bufnr, 1)
                                        unlet default  " for Vim without patch-7.4.1546
                                    endfor
                            
                                    " Check settings, without setting a default.
                                    for key in ['cwd']
                                        let setting = neomake#utils#GetSetting(key, {'name': maker.name}, get(maker, key, s:unset), ft, bufnr, 1)
                                        if setting isnot s:unset
                                            let maker[key] = setting
                                        endif
                                    endfor
                                endif
                                if v:profiling
                                    call add(s:hack_keep_refs_for_profiling, maker)
                                endif
                                return maker

FUNCTION  cursorword#cursormoved()
    Defined: ~\.SpaceVim\bundle\vim-cursorword\autoload\cursorword.vim:47
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if get(w:, 'cursorword_match')
                                  silent! call matchdelete(w:cursorword_id0)
                                  silent! call matchdelete(w:cursorword_id1)
                                  let w:cursorword_match = 0
                                  let w:cursorword_state = []
                                endif
                                call timer_stop(s:timer)
                                let s:timer = timer_start(s:delay, 'cursorword#timer_callback')

FUNCTION  bm#has_bookmarks_in_file()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:8
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(g:line_map, a:file)
                                return 0
                              endif
                              return len(keys(g:line_map[a:file])) > 0

FUNCTION  <SNR>346_add_snr()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:240
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname

FUNCTION  context_filetype#version()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:21
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return str2nr(printf('%02d%02d', 1, 0))

FUNCTION  deoplete#mapping#_restore_completeopt()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\mapping.vim:129
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
                              endif

FUNCTION  232()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\matchparen.vim:131
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('w:matchup_match_id_list')
                                for l:id in w:matchup_match_id_list
                                  silent! call matchdelete(l:id)
                                endfor
                                unlet! w:matchup_match_id_list
                              endif
                            
                              if exists('t:match_popup') && (exists('*win_gettype') ? win_gettype() !=# 'popup' : &buftype !=# 'terminal')
                                call popup_hide(t:match_popup)
                              elseif has('nvim')
                                call s:close_floating_win()
                              endif
                            
                              if exists('w:matchup_oldstatus')
                                let &l:statusline = w:matchup_oldstatus
                                unlet w:matchup_oldstatus
                                if exists('#User#MatchupOffscreenLeave')
                                  doautocmd <nomodeline> User MatchupOffscreenLeave
                                endif
                              endif
                              if exists('w:matchup_statusline')
                                unlet w:matchup_statusline
                              endif
                            
                              let w:matchup_need_clear = 0

FUNCTION  233()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\matchparen.vim:195
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              ""
                              " fade feature: remove highlights after a certain time
                              " {level}
                              "   =  0: prepare for possible loss of cursor support
                              "   =  1: new highlights are coming (cancel prior fade)
                              "   =  2: end of new highlights
                              " {pos}     [lnum, column] of current match
                              " {token}   in/out saves state between calls
                              "
                              " returns 1 if highlighting should be canceled
                            
                              if !g:matchup_matchparen_deferred || !exists('w:matchup_fade_timer')
                                if a:level <= 0
                                  call s:matchparen.clear()
                                endif
                                return 0
                              endif
                            
                              " jumping between windows
                              if a:level == 0 && win_getid() != get(s:, 'save_win')
                                call timer_pause(w:matchup_fade_timer, 1)
                                if exists('w:matchup_fade_pos')
                                  unlet w:matchup_fade_pos
                                endif
                                call s:matchparen.clear()
                                let s:save_win = win_getid()
                              endif
                            
                              " highlighting might be stale
                              if a:level == 0
                                if exists('w:matchup_fade_pos')
                                  let a:token.save_pos = w:matchup_fade_pos
                                  unlet w:matchup_fade_pos
                                endif
                                if !w:matchup_need_clear
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                                return 0
                              endif
                            
                              " prepare for new highlighting
                              if a:level == 1
                                " if token has no save_pos, cursor was previously off of a match
                                if !has_key(a:token, 'save_pos') || a:pos != a:token.save_pos
                                  " clear immediately
                                  call timer_pause(w:matchup_fade_timer, 1)
                                  call s:matchparen.clear()
                                  return 0
                                endif
                                let w:matchup_fade_pos = a:token.save_pos
                                return 1
                              endif
                            
                              " new highlighting is active
                              if a:level == 2 && a:pos != get(w:, 'matchup_fade_pos', [])
                                " init fade request
                                let w:matchup_fade_pos = a:pos
                                let w:matchup_fade_start = reltime()
                                call timer_pause(w:matchup_fade_timer, 0)
                              endif
                            
                              return 0

FUNCTION  234()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\matchparen.vim:295
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
                                return s:matchparen.highlight()
                              endif
                            
                              if !exists('w:matchup_timer')
                                let s:show_delay = g:matchup_matchparen_deferred_show_delay
                                let s:hide_delay = g:matchup_matchparen_deferred_hide_delay
                                let w:matchup_timer = timer_start(s:show_delay, function('s:timer_callback', [ win_getid() ]), {'repeat': -1})
                                if !exists('w:matchup_need_clear')
                                  let w:matchup_need_clear = 0
                                endif
                                let s:fade_time = g:matchup_matchparen_deferred_fade_time
                                if s:fade_time > 0
                                  let w:matchup_fade_timer = timer_start(s:fade_time, function('s:fade_timer_callback', [ win_getid() ]), {'repeat': -1})
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                              endif
                            
                              " keep the timer alive with a heartbeat
                              let w:matchup_pulse_time = reltime()
                            
                              " if the timer is paused, some time has passed
                              if timer_info(w:matchup_timer)[0].paused
                                " unpause the timer
                                call timer_pause(w:matchup_timer, 0)
                            
                                " set the hi time to the pulse time
                                let w:matchup_hi_time = w:matchup_pulse_time
                              endif

FUNCTION  235()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\matchparen.vim:334
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !g:matchup_matchparen_enabled | return | endif
                            
                              if has('vim_starting') | return | endif
                            
                              if !g:matchup_matchparen_pumvisible && pumvisible() | return | endif
                            
                              if !get(b:, 'matchup_matchparen_enabled', 1) && get(b:, 'matchup_matchparen_fallback', 1) && s:pi_paren_sid()
                                return call(s:pi_paren_fcn, [])
                              endif
                            
                              if !get(b:, 'matchup_matchparen_enabled', 1) | return | endif
                            
                              let l:force_update    = a:0 >= 1 ? a:1 : 0
                              let l:changing_insert = a:0 >= 2 ? a:2 : 0
                              let l:real_mode = l:changing_insert ? v:insertmode : mode()
                            
                              if !l:force_update && exists('w:last_changedtick') && exists('w:last_cursor') && matchup#pos#equal(w:last_cursor, matchup#pos#get_cursor()) && w:last_changedtick == b:changedtick
                                return
                              endif
                              let w:last_changedtick = b:changedtick
                              let w:last_cursor = matchup#pos#get_cursor()
                            
                              call matchup#perf#tic('matchparen.highlight')
                            
                              " request eventual clearing of stale matches
                              let l:token = {}
                              call self.fade(0, [], l:token)
                            
                              let l:modes = g:matchup_matchparen_nomode
                              if get(g:, 'matchup_matchparen_novisual', 0)  " deprecated option name
                                let l:modes .= "vV\<c-v>"
                              endif
                              if stridx(l:modes, l:real_mode) >= 0
                                return
                              endif
                            
                              " prevent problems in visual block mode at the end of a line
                              if get(matchup#pos#get_cursor(), 4, 0) == 2147483647
                                return
                              endif
                            
                              " don't get matches when inside a closed fold
                              if foldclosed(line('.')) > -1
                                return
                              endif
                            
                              " give up when cursor is far into a very long line
                              if &synmaxcol && col('.') > &synmaxcol
                                return
                              endif
                            
                              " in insert mode, cursor is treated as being one behind
                              let l:insertmode = l:real_mode ==# 'i'
                            
                              " start the timeout period
                              let l:timeout = l:insertmode ? get(b:, 'matchup_matchparen_insert_timeout',           g:matchup_matchparen_insert_timeout) : get(b:, 'matchup_matchparen_timeout',           g:matchup_matchparen_timeout)
                              call matchup#perf#timeout_start(l:timeout)
                            
                              let l:current = matchup#delim#get_current('all', 'both_all', { 'insertmode': l:insertmode,   'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
                              call matchup#perf#toc('matchparen.highlight', 'get_current')
                              if empty(l:current)
                                if get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred) && get(b:, 'matchup_matchparen_hi_surround_always',        g:matchup_matchparen_hi_surround_always)
                                   call s:highlight_surrounding(l:insertmode)
                                endif
                                return
                              endif
                            
                              let l:corrlist = matchup#delim#get_matching(l:current, { 'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
                              call matchup#perf#toc('matchparen.highlight', 'get_matching')
                              if empty(l:corrlist) | return | endif
                            
                              if g:matchup_transmute_enabled
                                if !exists('w:matchup_matchparen_context')
                                  let w:matchup_matchparen_context = { 'normal': {   'current':   {},   'corrlist':  [],  }, 'prior': {}, 'counter': 0,}
                                endif
                            
                                let w:matchup_matchparen_context.counter += 1
                            
                                if !l:insertmode
                                  let w:matchup_matchparen_context.prior = copy(w:matchup_matchparen_context.normal)
                            
                                  let w:matchup_matchparen_context.normal.current = l:current
                                  let w:matchup_matchparen_context.normal.corrlist = l:corrlist
                                endif
                            
                                " if transmuted, highlight again (will reset timeout)
                                if matchup#transmute#tick(l:insertmode)
                                  " no force_update here because it would screw up prior
                                  return s:matchparen.highlight(0, l:changing_insert)
                                endif
                              endif
                            
                              if !has_key(l:current, 'match_index') || len(l:corrlist) <= (l:current.side ==# 'mid' ? 2 : 1) && !g:matchup_matchparen_singleton
                                " TODO this doesn't catch every case, needs refactor
                                " TODO singleton doesn't work right for mids
                                return
                              endif
                            
                              " prepare for (possibly) new highlights
                              let l:pos = [l:current.lnum, l:current.cnum]
                              if self.fade(1, l:pos, l:token)
                                return
                              endif
                            
                              " store flag meaning highlighting is active
                              let w:matchup_need_clear = 1
                            
                              " disable off-screen when scrolling with j/k
                              let l:scrolling = get(g:matchup_matchparen_offscreen, 'scrolloff', 0) && winheight(0) > 2*&scrolloff && (line('.') == line('w$')-&scrolloff     && line('$') != line('w$')     || line('.') == line('w0')+&scrolloff)
                            
                              " show off-screen matches
                              let l:method = get(g:matchup_matchparen_offscreen, 'method', '')
                              if !empty(l:method) && l:method !=# 'none' && !l:current.skip && !l:scrolling && winheight(0) > 0
                                call s:do_offscreen(l:current, l:method)
                              endif
                            
                              " add highlighting matches
                              call s:add_matches(l:corrlist, l:current)
                            
                              " highlight the background between parentheses
                              if g:matchup_matchparen_hi_background >= 1
                                call s:highlight_background(l:corrlist)
                              endif
                            
                              " new highlights done, request fade away
                              call self.fade(2, l:pos, l:token)
                            
                              call matchup#perf#toc('matchparen.highlight', 'end')

FUNCTION  neoinclude#include#initialize()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\include.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let s:include_info = {}
                              let s:include_cache = {}
                              let s:async_include_cache = {}
                              let s:cached_pattern = {}
                            
                              augroup neoinclude
                                autocmd BufWritePost * call s:check_buffer('', 0)
                              augroup END

FUNCTION  <SNR>344_clearOldFolds()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\fileinfo.vim:122
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('self._tagfolds_old')
                                    unlet self._tagfolds_old
                                endif

FUNCTION  defx#call_action()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx.vim:61
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &l:filetype !=# 'defx'
                                return
                              endif
                            
                              let context = defx#init#_context({})
                              let args = defx#util#convert2list(get(a:000, 0, []))
                              call defx#util#rpcrequest( '_defx_do_action', [a:action, args, context], v:false)

FUNCTION  <SNR>22_neomake_signatures_current_error()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\checkers.vim:287
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:neomake_signatures_clear()
                              try
                                let message = neomake#GetCurrentErrorMsg()
                              catch /^Vim\%((\a\+)\)\=:E117/
                                let message = ''
                              endtry
                              if empty(message)
                                if exists('s:last_echoed_error')
                                  unlet s:last_echoed_error
                                endif
                                return
                              endif
                              if exists('s:last_echoed_error') && s:last_echoed_error == message
                                return
                              endif
                              let s:last_echoed_error = message
                              if len(line('.') + 1) > len(message)
                                let message = s:STRING.fill(message, len(line('.') + 1))
                              endif
                              call s:SIG.info(line('.') + 1, 1, message)

FUNCTION  deoplete#custom#_get()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:60
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              return s:custom

FUNCTION  <SNR>372_GetMarkdownStyleInModeline()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:372
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002   let l:myFileType = &filetype
    1              0.000005   let l:lst = split(l:myFileType, "\\.")
    1              0.000003   if len(l:lst) == 2 && l:lst[1] ==# "markdown"
                                return l:lst[0]
    1              0.000000   else
    1              0.000001     return "Unknown"
                              endif

FUNCTION  259()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:825
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(self._files, a:fname, {})

FUNCTION  neomake#utils#load_ft_makers()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:154
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " Load ft maker, but only once (for performance reasons and to allow for
                                " monkeypatching it in tests).
                                if index(s:loaded_ft_maker_runtime, a:ft) == -1
                                    if !exists('*neomake#makers#ft#'.a:ft.'#EnabledMakers')
                                        silent exe 'runtime! autoload/neomake/makers/ft/'.a:ft.'.vim'
                                    endif
                                    call add(s:loaded_ft_maker_runtime, a:ft)
                                endif

FUNCTION  gtags#update()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\gtags.vim:446
Called 1 time
Total time:   0.018212
 Self time:   0.000457

count  total (s)   self (s)
    1              0.000015   call s:LOGGER.debug('start to update gtags database')
    1   0.000486   0.000039   let dir = s:FILE.unify_path(g:tags_cache_dir)  . s:FILE.path_to_fname(SpaceVim#plugins#projectmanager#current_root())
    1              0.000013   call s:LOGGER.debug('            dir:' . dir)
    1              0.000007   call s:LOGGER.debug('         single:' . a:single_update)
    1              0.000062   if !isdirectory(dir)
                                if !mkdir(dir, 'p')
                                  call s:LOGGER.debug('failed to create dir:' . dir)
                                  return
                                endif
    1              0.000000   endif
    1              0.000002   let cmd = ['gtags']
    1              0.000002   if !empty(g:gtags_gtagslabel)
                                let cmd += ['--gtagslabel=' . g:gtags_gtagslabel]
    1              0.000000   endif
    1              0.000096   if a:single_update && filereadable(dir . '/GTAGS')
    1              0.000158     let cmd += ['--single-update', expand('%:p')]
                              else
                                let cmd += ['--skip-unreadable']
    1              0.000000   endif
    1              0.000002   let cmd += ['-O', dir]
    1              0.000016   call s:LOGGER.debug('      gtags cmd:' . string(cmd))
    1   0.017340   0.000032   call s:LOGGER.debug('   gtags job id:' . s:JOB.start(cmd, {'on_exit' : funcref('s:on_update_exit')}))

FUNCTION  defx#redraw()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx.vim:81
Called 1 time
Total time:   0.000356
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000355   0.000014   call defx#util#rpcrequest('_defx_redraw', [], v:false)

FUNCTION  260()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:831
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 == 1
                                let self._files[a:1] = a:fileinfo
                              else
                                let fname = a:fileinfo.fpath
                                let self._files[fname] = a:fileinfo
                              endif

FUNCTION  261()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:841
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return has_key(self._files, a:fname)

FUNCTION  deoplete#handler#_completion_begin()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:182
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call deoplete#custom#_update_cache()
                            
                              let auto_popup = deoplete#custom#_get_option( 'auto_complete_popup') !=# 'manual'
                              let prev_input = get(g:deoplete#_context, 'input', '')
                              let cur_input = deoplete#util#get_input(a:event)
                            
                              let check_back_space = auto_popup && cur_input !=# prev_input && len(cur_input) + 1 ==# len(prev_input) && stridx(prev_input, cur_input) == 0
                              let refresh_backspace = deoplete#custom#_get_option('refresh_backspace')
                            
                              if s:is_skip(a:event) || (check_back_space && !refresh_backspace)
                                let g:deoplete#_context.candidates = []
                                let g:deoplete#_context.input = cur_input
                                return
                              endif
                            
                              if auto_popup && deoplete#handler#_check_prev_completion(a:event)
                                call feedkeys("\<Plug>+", 'i')
                              endif
                            
                              if a:event !=# 'Update' && a:event !=# 'Async'
                                call deoplete#init#_prev_completion()
                              endif
                            
                              call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', {'event': a:event})
                            
                              " For <BS> popup flicker
                              if check_back_space && empty(v:completed_item)
                                call feedkeys("\<Plug>_", 'i')
                              endif

FUNCTION  278()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\state.vim:41
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let self._current = a:fileinfo

FUNCTION  <SNR>40_filename()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:154
Called 1 time
Total time:   0.000154
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003   let name = fnamemodify(bufname('%'), ':t')
    1              0.000001   if empty(name)
                                let name = 'No Name'
    1              0.000000   endif
    1   0.000148   0.000013   return "%{ &modified ? ' * ' : ' - '}" . s:filesize() . name . ' '

FUNCTION  <SNR>303_run_system()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3094
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('win32') && !has('nvim') && a:version > 0 && (has('python3') || has('python2'))
                                if a:version == 3 && has('python3')
                                  let pyx = 'py3 '
                                  let python_eval = 'py3eval'
                                elseif a:version == 2 && has('python2')
                                  let pyx = 'py2 '
                                  let python_eval = 'pyeval'
                                else
                                  let pyx = 'pyx '
                                  let python_eval = 'pyxeval'
                                endif
                                let l:pc = 0
                                exec pyx . 'import subprocess, vim'
                                exec pyx . '__argv = {"args":vim.eval("a:cmd"), "shell":True}'
                                exec pyx . '__argv["stdout"] = subprocess.PIPE'
                                exec pyx . '__argv["stderr"] = subprocess.STDOUT'
                                exec pyx . '__argv["errors"] = "ignore"'
                                exec pyx . '__pp = subprocess.Popen(**__argv, universal_newlines=True, encoding="utf8")'
                                exec pyx . '__return_text = __pp.stdout.read()'
                                exec pyx . '__pp.stdout.close()'
                                exec pyx . '__return_code = __pp.wait()'
                                exec 'let l:hr = '. python_eval .'("__return_text")'
                                exec 'let l:pc = '. python_eval .'("__return_code")'
                                let s:shell_error = l:pc
                                return l:hr
                              endif
                              let hr = system(a:cmd)
                              let s:shell_error = v:shell_error
                              return hr

FUNCTION  defx#init#_initialize()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\init.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('g:defx#_channel_id')
                                return
                              endif
                            
                              call defx#init#_channel()
                            
                              augroup defx
                                autocmd!
                              augroup END
                            
                              let g:defx#_histories = []
                              let g:defx#_previewed_buffers = {}

FUNCTION  <SNR>50_tabname()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:114
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let name = bufname(a:bufnr)
                              if name ==# '\[Vader\]'
                                let fn = '[Vader]'
                              elseif name =~# 'term://.*'
                                let fn = 'Terminal'
                              else
                                let fn = fnamemodify(name, ':t')
                              endif
                              if g:spacevim_enable_tabline_ft_icon || get(g:, 'spacevim_enable_tabline_filetype_icon', 0)
                                let icon = s:FILE.fticon(fn)
                                if !empty(icon)
                                  let fn = fn . ' ' . icon
                                endif
                              endif
                              if empty(fn)
                                return 'No Name'
                              else
                                return fn
                              endif

FUNCTION  <SNR>131_resolve_name()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\config.vim:16
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000010     let parts = type(a:name) == type([]) ? a:name : split(a:name, '\.')
    3              0.000004     if a:validate && parts[0] ==# 'neomake'
                                    throw printf( 'Neomake: config: "neomake" is not necessary with new-style config settings (%s).', string(a:name))
    3              0.000001     endif
    3              0.000003     let c = a:dict
    3              0.000005     for p in parts[0:-2]
    2              0.000003         if !has_key(c, p)
    2              0.000001             if !a:init
    2              0.000003                 return [g:neomake#config#undefined, '']
                                        endif
                                        let c[p] = {}
                                    endif
                                    if type(c[p]) != type({})
                                        return [g:neomake#config#undefined, '']
                                    endif
                                    let c = c[p]
    1              0.000001     endfor
    1              0.000001     return [c, parts[-1]]

FUNCTION  neosnippet#helpers#get_filetype()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\helpers.vim:72
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " context_filetype.vim installation check.
                              if !exists('s:exists_context_filetype')
                                silent! call context_filetype#version()
                                let s:exists_context_filetype = exists('*context_filetype#version')
                              endif
                            
                              let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
                              if context_filetype ==# ''
                                let context_filetype = 'nothing'
                              endif
                            
                              return context_filetype

FUNCTION  neosnippet#handlers#_cursor_moved()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\handlers.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let expand_stack = neosnippet#variables#expand_stack()
                            
                              " Get patterns and count.
                              if !&l:modifiable || !&l:modified || empty(expand_stack)
                                return
                              endif
                            
                              let expand_info = expand_stack[-1]
                              if expand_info.begin_line == expand_info.end_line && line('.') != expand_info.begin_line
                                call neosnippet#view#_clear_markers(expand_info)
                              endif

FUNCTION  <SNR>40_winnr()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:132
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001   if a:0 >= 1
                                if g:spacevim_windows_index_type == 3
                                  return ' %{ get(w:, "winid", winnr()) } '
                                else
                                  return ' %{ SpaceVim#layers#core#statusline#winnr(get(w:, "winid", winnr())) } '
                                endif
    1              0.000000   else
    1              0.000001     if g:spacevim_enable_statusline_mode == 1
    1              0.000002       return '%{SpaceVim#layers#core#statusline#mode(mode())} %{SpaceVim#layers#core#statusline#mode_text(mode())} %{ SpaceVim#layers#core#statusline#winnr(get(w:, "winid", winnr())) } '
                                elseif g:spacevim_windows_index_type == 3
                                  return '%{SpaceVim#layers#core#statusline#mode(mode())} %{ get(w:, "winid", winnr()) } '
                                else
                                  return '%{SpaceVim#layers#core#statusline#mode(mode())} %{ SpaceVim#layers#core#statusline#winnr(get(w:, "winid", winnr())) } '
                                endif
                              endif

FUNCTION  <SNR>324_get_same_filetypes()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:468
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let same_filetypes = extend(copy(s:default_same_filetypes), g:context_filetype#same_filetypes)
                              return split(get(same_filetypes, a:filetype, get(same_filetypes, '_', '')), ',')

FUNCTION  <SNR>126_neomake_automake()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:619
Called 1 time
Total time:   0.000840
 Self time:   0.000083

count  total (s)   self (s)
    1   0.000415   0.000023     let disabled = neomake#config#get_with_source('disabled', 0)
    1              0.000001     if disabled[0]
                                    call s:debug_log(printf('disabled (%s)', disabled[1]))
                                    return
    1              0.000000     endif
    1              0.000001     let bufnr = +a:bufnr
                            
    1              0.000002     if has_key(s:configured_buffers, bufnr)
    1              0.000002         let buffer_config = s:configured_buffers[bufnr]
                                else
                                    " Register the buffer, and remember that it's automatic.
                                    let buffer_config = s:configure_buffer(bufnr)
    1              0.000000     endif
    1              0.000002     if get(buffer_config, 'ignore', 0)
                                    " NOTE: might be too verbose.
                                    call s:debug_log('buffer is ignored')
                                    return
    1              0.000000     endif
                            
    1              0.000002     if s:need_to_skip_first_textchanged && a:event ==# 'TextChanged'
                                    if !getbufvar(bufnr, '_neomake_seen_TextChanged', 0)
                                        call s:debug_log('ignoring first TextChanged')
                                        call setbufvar(bufnr, '_neomake_seen_TextChanged', 1)
                                        return
                                    endif
    1              0.000000     endif
                            
    1   0.000216   0.000016     call s:debug_log(printf('handling event %s', a:event), {'bufnr': bufnr})
                            
    1              0.000003     if empty(s:configured_buffers[bufnr].maker_jobs)
    1   0.000178   0.000013         call s:debug_log('no enabled makers', {'bufnr': bufnr})
    1              0.000000         return
                                endif
                            
                                if s:skip_for_running_jobs(bufnr)
                                    return
                                endif
                            
                                call s:debug_log(printf('automake for event %s', a:event), {'bufnr': bufnr})
                                let config = s:configured_buffers[bufnr].events_config
                                if !has_key(config, a:event)
                                    call s:debug_log('event is not registered', {'bufnr': bufnr})
                                    return
                                endif
                                let config = config[a:event]
                            
                                let event = a:event
                                let bufnr = +a:bufnr
                                " TODO: rename to neomake.automake.delay
                                let delay = get(config, 'delay', s:get_setting('automake_delay', s:default_delay))
                                let context = { 'delay': delay, 'bufnr': bufnr, 'event': a:event, 'maker_jobs': s:configured_buffers[bufnr].maker_jobs, }
                                if event ==# 'BufWinEnter'
                                    " Ignore context, so that e.g. with vim-stay restoring the view
                                    " (cursor position), it will still be triggered.
                                    let context.pos = []
                                endif
                                call s:neomake_do_automake(context)

FUNCTION  <SNR>24_format()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\format.vim:97
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000009   if !empty(&ft) && ( index(s:format_ft, &ft) !=# -1 || s:format_on_save ==# 1)
                            
                                if s:format_method ==# 'neoformat'
                                  undojoin | Neoformat
                                elseif s:format_method ==# 'codefmt'
                                  undojoin | FormatCode
                                endif
    1              0.000000   endif

FUNCTION  <SNR>333_cursormoved_delayed_cb()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2518
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if getpos('.') == s:cursormoved_last_pos
                                    call neomake#CursorMoved()
                                endif

FUNCTION  SpaceVim#mapping#menu()
    Defined: ~\.SpaceVim\autoload\SpaceVim\mapping.vim:313
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let description = '➤ '. a:desc. repeat(' ', 80 - len(a:desc) - len(a:key)). a:key
                              call add(g:unite_source_menu_menus.CustomKeyMaps.command_candidates, [description , a:cmd])

FUNCTION  <SNR>250_add_missing_signs()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:483
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let bookmarks = values(bm#all_bookmarks_by_line(a:file))
                              for bookmark in bookmarks
                                call bm_sign#add_at(a:file, bookmark['sign_idx'], bookmark['line_nr'], bookmark['annotation'] !=# "")
                              endfor

FUNCTION  tagbar#sorting#sort()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\sorting.vim:5
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let s:compare_typeinfo = a:compare_typeinfo
                            
                                let comparemethod = a:compareby ==# 'kind' ? 's:compare_by_kind' : 's:compare_by_line'
                            
                                call sort(a:tags, comparemethod)
                            
                                for tag in a:tags
                                    if !empty(tag.getChildren())
                                        call tagbar#sorting#sort(tag.getChildren(), a:compareby, a:compare_typeinfo)
                                    endif
                                endfor

FUNCTION  <SNR>7_isDarwin()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\system.vim:45
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   if exists('s:is_darwin')
    1              0.000001     return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  <SNR>22_neomake_cursor_move_delay()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\checkers.vim:196
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:neomake_signatures_clear()
                              let s:neomake_cursormoved_timer = timer_start(g:neomake_cursormoved_delay, function('s:neomake_signatures_current_error'))

FUNCTION  <SNR>372_GetSections()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:70
Called 3 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000006   let l:winview = winsaveview()
    3              0.000003   let l:sections = {}
                            
    3              0.000018   keepjumps normal! gg0
    3              0.000003   let l:flags = "Wc"
    3              0.000002   let l:beginLine = 0
    3              0.000003   let l:regex = a:beginRegex
    7              0.000032   while search(l:regex, l:flags)
    4              0.000005     let l:lineNum = line(".")
    4              0.000003     if l:beginLine == 0
    2              0.000002       let l:beginLine = l:lineNum
    2              0.000002       let l:regex = a:endRegex
    2              0.000001     else
    2              0.000004       let l:sections[l:beginLine] = l:lineNum
    2              0.000002       let l:beginLine = 0
    2              0.000002       let l:regex = a:beginRegex
    4              0.000001     endif
    4              0.000004     let l:flags = "W"
    7              0.000003   endwhile
                            
    3              0.000005   call winrestview(l:winview)
                            
    3              0.000002   return l:sections

FUNCTION  neoinclude#util#cd()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:127
Called 1 time
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    1              0.000003   let cwd = getcwd()
    1              0.000055   if !isdirectory(a:dir) || a:dir ==# cwd
                                return []
    1              0.000000   endif
                            
    1              0.000006   let cd_command = haslocaldir() ? 'lcd' : (exists(':tcd') == 2 && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
    1              0.000159   silent! execute cd_command fnameescape(a:dir)
    1              0.000003   return [cd_command, cwd]

FUNCTION  <SNR>73_mappings()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\lang\markdown.vim:139
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('g:_spacevim_mappings_space')
                                let g:_spacevim_mappings_space = {}
                              endif
                              let g:_spacevim_mappings_space.l = {'name' : '+Language Specified'}
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','p'], 'MarkdownPreview', 'Real-time markdown preview', 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','k'], '<plug>(markdown-insert-link)', 'add link url', 0, 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','K'], '<plug>(markdown-insert-picture)', 'add link picture', 0, 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l', 'r'],  'call call(' . string(function('s:run_code_in_block')) . ', [])', 'run code in block', 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','c'], 'GenTocGFM', 'create content at cursor', 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','C'], 'RemoveToc', 'remove content', 1)
                              call SpaceVim#mapping#space#langSPC('nmap', ['l','u'], 'UpdateToc', 'update content', 1)

FUNCTION  <SNR>303_ExecuteCtagsOnFile()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1366
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
                              if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                " if ctagsargs is a string, prepend and append space separators
                                let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                              elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                              else
                                "Prefer constructing ctags_args as a list rather than a string
                                "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                "each arg separately because in special cases where space is
                                "intended to be in an argument, spaces in a single ctag_args
                                "string would be ambiguous. Is the space an argument separator
                                "or to be included in the argument
                                let ctags_args = []
                                if exists('g:tagbar_ctags_options')
                                  for value in g:tagbar_ctags_options
                                    call add(ctags_args, '--options='.value)
                                  endfor
                                endif
                            
                                " universal-ctags deprecated this argument name
                                if s:ctags_is_uctags
                                  let ctags_args += [ '--extras=+F' ]
                                else
                                  let ctags_args += [ '--extra=', '--file-scope=yes' ]
                                endif
                            
                                let ctags_args  = ctags_args + [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSafet', '--sort=no', '--append=no' ]
                            
                                " verbose if debug enabled
                                if tagbar#log#debug_enabled()
                                  let ctags_args += [ '-V' ]
                                endif
                            
                                " Third-party programs may not necessarily make use of this
                                if has_key(a:typeinfo, 'ctagstype')
                                  let ctags_type = a:typeinfo.ctagstype
                            
                                  let ctags_kinds = ''
                                  for kind in a:typeinfo.kinds
                                    if kind.short !=# '?'
                                      let ctags_kinds .= kind.short
                                    endif
                                  endfor
                            
                                  let ctags_args += ['--language-force=' . ctags_type]
                                  let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
                                endif
                            
                                " Include extra type definitions - include last to allow for any
                                " overrides
                                if has_key(a:typeinfo, 'deffile') && filereadable(expand(a:typeinfo.deffile))
                                  let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                endif
                            
                                if has_key(a:typeinfo, 'regex')
                                  for regex in a:typeinfo.regex
                                    let ctags_args += ['--regex-' . ctags_type . '=' . regex]
                                  endfor
                                endif
                              endif
                            
                              if has_key(a:typeinfo, 'ctagsbin')
                                " reset 'wildignore' temporarily in case *.exe is included in it
                                let wildignore_save = &wildignore
                                set wildignore&
                                let ctags_bin = expand(a:typeinfo.ctagsbin)
                                let &wildignore = wildignore_save
                              else
                                let ctags_bin = g:tagbar_ctags_bin
                              endif
                            
                              let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
                              if ctags_cmd ==# ''
                                return ''
                              endif
                            
                              let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
                              if v:shell_error || ctags_output =~? 'Warning: cannot open \(source\|input\) file'
                                call tagbar#log#debug('Command output:')
                                call tagbar#log#debug(ctags_output)
                                call tagbar#log#debug('Exit code: ' . v:shell_error)
                                " Only display an error message if the Tagbar window is open and we
                                " haven't seen the error before.
                                if bufwinnr(s:TagbarBufName()) != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                  call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                  echomsg 'Executed command: "' . ctags_cmd . '"'
                                  if !empty(ctags_output)
                                    echomsg 'Command output:'
                                    for line in split(ctags_output, '\n')
                                      echomsg line
                                    endfor
                                  endif
                                  echomsg 'Exit code: ' . v:shell_error
                                endif
                                return -1
                              endif
                            
                              call tagbar#log#debug('Ctags executed successfully')
                            
                              return ctags_output

FUNCTION  <SNR>303_HighlightTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:2245
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            
                              if g:tagbar_no_autocmds
                                " If no autocmds are enabled, then it doesn't make sense to highlight
                                " anything as the cursor can move around and any highlighting would be
                                " inaccurate
                                return
                              endif
                            
                              let noauto = a:0 > 0 ? a:1 : 0
                            
                              let tagline = 0
                            
                              let force = a:0 > 1 ? a:2 : 0
                            
                              if a:0 > 2
                                let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0, a:3)
                              else
                                let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0)
                              endif
                              if !empty(tag)
                                let tagline = tag.tline
                              endif
                            
                              " Don't highlight the tag again if it's the same one as last time.
                              " This prevents the Tagbar window from jumping back after scrolling with
                              " the mouse.
                              if !force && tagline ==# s:last_highlight_tline
                                return
                              else
                                let s:last_highlight_tline = tagline
                              endif
                            
                              let tagbarwinnr = bufwinnr(s:TagbarBufName())
                              if tagbarwinnr == -1
                                return
                              endif
                            
                              if tagbarwinnr == winnr()
                                let in_tagbar = 1
                              else
                                let in_tagbar = 0
                                let prevwinnr = winnr()
                                call s:goto_win('p', 1)
                                let pprevwinnr = winnr()
                                call s:goto_win(tagbarwinnr, 1)
                              endif
                            
                              try
                                match none
                            
                                " No tag above cursor position so don't do anything
                                if tagline == 0
                                  return
                                endif
                            
                                if g:tagbar_autoshowtag == 1 || a:openfolds
                                  call s:OpenParents(tag)
                                endif
                            
                                " Check whether the tag is inside a closed fold and highlight the parent
                                " instead in that case
                                let tagline = tag.getClosedParentTline()
                            
                                " Parent tag line number is invalid, better don't do anything
                                if tagline <= 0
                                  return
                                endif
                            
                                " Go to the line containing the tag
                                execute tagline
                            
                                " Make sure the tag is visible in the window
                                call winline()
                            
                                let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                            
                                " If printing the line number of the tag to the left, and the tag is
                                " visible (I.E. parent isn't folded)
                                let identifier = '\zs\V' . escape(tag.name, '/\') . '\m\ze'
                                if g:tagbar_show_tag_linenumbers == 2 && tagline == tag.tline
                                  let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\[[0-9]\+\] \?' . identifier . '/'
                                else
                                  let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?' . identifier . '/'
                                endif
                                call tagbar#log#debug("Highlight pattern: '" . pattern . "'")
                                if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                  execute 'match TagbarHighlight ' . pattern
                                else
                                  execute 'match Search ' . pattern
                                endif
                              finally
                                if !in_tagbar
                                  call s:goto_win(pprevwinnr, 1)
                                  call s:goto_win(prevwinnr, noauto)
                                endif
                                redraw
                              endtry

FUNCTION  <SNR>129_get_oldstyle_setting()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:237
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let maker_name = get(a:maker, 'name', '')
                                if a:maker_only && empty(maker_name)
                                    if has_key(a:maker, a:key)
                                        return get(a:maker, a:key)
                                    endif
                                    return a:default
                                endif
                            
                                if !empty(a:ft)
                                    let fts = neomake#utils#get_config_fts(a:ft) + ['']
                                else
                                    let fts = ['']
                                endif
                                for ft in fts
                                    let part = join(filter([ft, maker_name], '!empty(v:val)'), '_')
                                    if empty(part)
                                        break
                                    endif
                                    let config_var = 'neomake_'.part.'_'.a:key
                                    if a:bufnr isnot# ''
                                        let l:Bufcfgvar = neomake#compat#getbufvar(a:bufnr, config_var, s:unset)
                                        if Bufcfgvar isnot s:unset
                                            return copy(Bufcfgvar)
                                        endif
                                    endif
                                    if has_key(g:, config_var)
                                        return copy(get(g:, config_var))
                                    endif
                                    unlet! Bufcfgvar  " vim73
                                endfor
                            
                                if has_key(a:maker, a:key)
                                    return get(a:maker, a:key)
                                endif
                            
                                let key = a:key
                                if a:maker_only
                                    let key = maker_name.'_'.key
                                endif
                                let key = a:maker_only ? maker_name.'_'.a:key : a:key
                                " Look for 'neomake_'.key in the buffer and global namespace.
                                let bufvar = neomake#compat#getbufvar(a:bufnr, 'neomake_'.key, s:unset)
                                if bufvar isnot s:unset
                                    return bufvar
                                endif
                                if a:key !=# 'enabled_makers' && has_key(g:, 'neomake_'.key)
                                    return get(g:, 'neomake_'.key)
                                endif
                                return a:default

FUNCTION  <SNR>303_ShrinkIfExpanded()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1136
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !s:window_expanded || &filetype ==# 'tagbar' || s:expand_bufnr == -1
                                return
                              endif
                            
                              let tablist = []
                              for i in range(tabpagenr('$'))
                                call extend(tablist, tabpagebuflist(i + 1))
                              endfor
                            
                              if index(tablist, s:expand_bufnr) == -1
                                let &columns -= g:tagbar_width + 1
                                let s:window_expanded = 0
                                let s:expand_bufnr = -1
                                " Only restore window position if it is available and if the
                                " window hasn't been moved manually after the expanding
                                if getwinposx() != -1 && getwinposx() == s:window_pos.post.x && getwinposy() == s:window_pos.post.y
                                  execute 'winpos ' . s:window_pos.pre.x . ' ' . s:window_pos.pre.y
                                endif
                              endif
                            
                              " The window sizes may have changed due to the shrinking happening after
                              " the window closing, so equalize them again.
                              if &equalalways
                                wincmd =
                              endif

FUNCTION  <SNR>451_get_context_filetypes()
    Defined: ~\.SpaceVim\bundle\neco-syntax\autoload\necosyntax.vim:240
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
                              return s:exists_context_filetype && exists('*context_filetype#get_filetypes') ? context_filetype#get_filetypes(a:filetype) : [a:filetype]

FUNCTION  tagbar#is_paused()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3859
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return s:paused

FUNCTION  deoplete#util#check_popup()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:209
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return exists('*complete_info') && complete_info().mode ==# 'eval'

FUNCTION  <SNR>459_iconv()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:81
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:from == '' || a:to == '' || a:from ==? a:to
                                return a:expr
                              endif
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr

FUNCTION  <SNR>460_get_include_files()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\include.vim:150
Called 1 time
Total time:   0.001263
 Self time:   0.001263

count  total (s)   self (s)
    1              0.000001   let include_files = []
   52              0.000031   for line in a:lines
   51              0.000202     if line =~ a:pattern
                                  let match_end = matchend(line, a:pattern)
                                  if a:expr != ''
                                    let eval = substitute(a:expr, 'v:fname', string(matchstr(line[match_end :], '\f\+')), 'g')
                                    try
                                      let filename = fnamemodify(findfile(eval(eval), a:path), ':p')
                                    catch
                                      " Error
                                      let filename = ''
                                    endtry
                                  else
                                    let filename = fnamemodify(findfile( matchstr(line[match_end :], '\f\+'), a:path), ':p')
                                  endif
                            
                                  if filereadable(filename)
                                    call add(include_files, filename)
                            
                                    if a:nestlevel < 1
                                      " Nested include files.
                                      let include_files += s:get_include_files( a:nestlevel + 1, readfile(filename, '', 100), a:filetype, a:pattern, a:path, a:expr)
                                    endif
                                  elseif isdirectory(filename) && a:filetype ==# 'java'
                                    " For Java import with *.
                                    " Ex: import lejos.nxt.*
                                    let include_files += neoinclude#util#glob(filename . '/*.java')
                                  endif
   51              0.000012     endif
   52              0.000015   endfor
                            
    1              0.000001   return include_files

FUNCTION  <SNR>372_GenTocInner()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:274
Called 1 time
Total time:   0.001627
 Self time:   0.000417

count  total (s)   self (s)
    1              0.000002   if index(s:supportMarkdownStyles, a:markdownStyle) == -1
                                echom "Unsupport markdown style: " . a:markdownStyle
                                return
    1              0.000000   endif
                            
    1   0.000905   0.000015   let l:headingLines = <SID>GetHeadingLines()
    1              0.000001   let l:levels = []
    1              0.000002   let l:listItemChars = [g:vmt_list_item_char]
                            
    1              0.000008   let g:GFMHeadingIds = {}
                            
    5              0.000004   for headingLine in l:headingLines
    4   0.000067   0.000054     call add(l:levels, <SID>GetHeadingLevel(headingLine))
    5              0.000002   endfor
                            
    1              0.000003   let l:minLevel = max([min(l:levels),g:vmt_min_level])
                            
    1              0.000001   if g:vmt_dont_insert_fence == 0
    1   0.000024   0.000018     silent put =<SID>GetBeginFence(a:markdownStyle, a:isModeline)
    1              0.000000   endif
                            
    1              0.000001   if g:vmt_cycle_list_item_markers == 1
                                let l:listItemChars = ['*', '-', '+']
    1              0.000000   endif
                            
    1              0.000001   let l:i = 0
                              " a black line before toc
    1              0.000001   if !empty(l:headingLines)
    1              0.000002     silent put =''
    1              0.000000   endif
                            
    5              0.000004   for headingLine in l:headingLines
    4   0.000135   0.000052     let l:headingName = <SID>GetHeadingName(headingLine)
                                " only add line if less than max level and greater than min level
    4              0.000010     if l:levels[i] <= g:vmt_max_level && l:levels[i] >= g:vmt_min_level
    4              0.000006       let l:headingIndents = l:levels[i] - l:minLevel
    4              0.000012       let l:listItemChar = l:listItemChars[(l:levels[i] + 1) % len(l:listItemChars)]
                                  " make link if desired, otherwise just bullets
    4              0.000003       if g:vmt_link
    4   0.000257   0.000053         let l:headingLink = <SID>GetHeadingLink(l:headingName, a:markdownStyle)
    4   0.000063   0.000051         let l:heading = repeat(s:GetIndentText(), l:headingIndents)
    4              0.000006         let l:heading = l:heading . l:listItemChar
    4              0.000008         let l:heading = l:heading . " [" . l:headingName . "]"
    4              0.000007         let l:heading = l:heading . "(#" . l:headingLink . ")"
                                  else
                                    let l:heading = repeat(s:GetIndentText(), l:headingIndents)
                                    let l:heading = l:heading . l:listItemChar
                                    let l:heading = l:heading . " " . l:headingName
    4              0.000001       endif
    4              0.000011       silent put =l:heading
    4              0.000001     endif
    4              0.000004     let l:i += 1
    5              0.000002   endfor
                            
                              " a blank line after toc to avoid effect typo of content below
    1              0.000002   silent put =''
                            
    1              0.000001   if g:vmt_dont_insert_fence == 0
    1   0.000016   0.000014     silent put =<SID>GetEndFence()
    1              0.000000   endif

FUNCTION  git#branch#current()
    Defined: ~\.SpaceVim\bundle\git.vim\autoload\git\branch.vim:115
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000005   let pwd = getcwd()
    2              0.000006   let branch = get(s:branch_info, pwd, {})
    2              0.000002   if empty(branch)
                                call s:update_branch_name(pwd)
    2              0.000001   endif
    2              0.000004   let branch_name = get(branch, 'name', '')
    2              0.000003   let prefix = get(a:000, 0 , '')
    2              0.000002   if !empty(branch_name)
    2              0.000004     return ' ' . prefix . ' ' . branch_name . ' '
                              else
                                return ''
                              endif

FUNCTION  <SNR>91_has_map_to_spc()
    Defined: ~\.SpaceVim\autoload\SpaceVim\mapping\space.vim:761
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'mapleader', '\') ==# ' '

FUNCTION  bm#location_list()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:130
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let files = sort(bm#all_files())
                              let locations = []
                              for file in files
                                let line_nrs = sort(bm#all_lines(file), "bm#compare_lines")
                                for line_nr in line_nrs
                                  let bookmark = bm#get_bookmark_by_line(file, line_nr)
                                  let content = bookmark['annotation'] !=# '' ? "Annotation: ". bookmark['annotation'] : (bookmark['content'] !=# ""   ? bookmark['content']   : "empty line")
                                  call add(locations, file .":". line_nr .":". content)
                                endfor
                              endfor
                              return locations

FUNCTION  <SNR>122_eval_cmdline()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:162
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cmdline = ''
                              let prev_match = 0
                              let eval_pos = match(a:cmdline, '\\\@<!`.\{-}\\\@<!`')
                              while eval_pos >= 0
                                if eval_pos - prev_match > 0
                                  let cmdline .= a:cmdline[prev_match : eval_pos - 1]
                                endif
                                let prev_match = matchend(a:cmdline, '\\\@<!`.\{-}\\\@<!`', eval_pos)
                                let cmdline .= escape(eval(a:cmdline[eval_pos+1 : prev_match - 2]), '\ ')
                            
                                let eval_pos = match(a:cmdline, '\\\@<!`.\{-}\\\@<!`', prev_match)
                              endwhile
                              if prev_match >= 0
                                let cmdline .= a:cmdline[prev_match :]
                              endif
                            
                              return cmdline

FUNCTION  <SNR>250_refresh_line_numbers()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:401
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:lazy_init()
                              let file = expand("%:p")
                              if file ==# "" || !bm#has_bookmarks_in_file(file)
                                return
                              endif
                              let bufnr = bufnr(file)
                              let sign_line_map = bm_sign#lines_for_signs(file)
                              for sign_idx in keys(sign_line_map)
                                let line_nr = sign_line_map[sign_idx]
                                let line_content = getbufline(bufnr, line_nr)
                                let content = len(line_content) > 0 ? line_content[0] : ' '
                                call bm#update_bookmark_for_sign(file, sign_idx, line_nr, content)
                              endfor

FUNCTION  <SNR>303_ParseTagline()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1488
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let basic_info  = split(a:part1, '\t')
                              let tagname  = basic_info[0]
                              let filename = basic_info[1]
                            
                              " the pattern can contain tabs and thus may have been split up, so join
                              " the rest of the items together again
                              let pattern = join(basic_info[2:], "\t")
                              if pattern[0] ==# '/'
                                let start   = 2 " skip the slash and the ^
                                let end     = strlen(pattern) - 1
                                if pattern[end - 1] ==# '$'
                                  let end -= 1
                                  let dollar = '\$'
                                else
                                  let dollar = ''
                                endif
                                let pattern = '\V\^\C' . strpart(pattern, start, end - start) . dollar
                              else
                                let pattern = ''
                              endif
                            
                              " When splitting fields make sure not to create empty keys or values in
                              " case a value illegally contains tabs
                              let fields = split(a:part2, '^\t\|\t\ze\w\+:')
                              let fielddict = {}
                              if fields[0] !~# ':'
                                let fielddict.kind = remove(fields, 0)
                              endif
                              for field in fields
                                " can't use split() since the value can contain ':'
                                let delimit = stridx(field, ':')
                                let key = strpart(field, 0, delimit)
                                " Remove all tabs that may illegally be in the value
                                let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                " File-restricted scoping
                                if key ==# 'file'
                                  let fielddict[key] = 'yes'
                                endif
                                if len(val) > 0
                                  if key ==# 'line' || key ==# 'column' || key ==# 'end'
                                    let fielddict[key] = str2nr(val)
                                  else
                                    let fielddict[key] = val
                                  endif
                                endif
                              endfor
                            
                              " If the tag covers multiple scopes, split it up and create individual tags
                              " for each scope so that the hierarchy can be displayed correctly.
                              " This can happen with PHP's 'namespace' tags in uctags, for example.
                              if has_key(a:typeinfo, 'kind2scope') && has_key(a:typeinfo.kind2scope, fielddict.kind) && tagname =~# '\V' . escape(a:typeinfo.sro, '\')
                                let tagparts = split(tagname, '\V' . escape(a:typeinfo.sro, '\'))
                            
                                let scope = a:typeinfo.kind2scope[fielddict.kind]
                                if has_key(fielddict, scope)
                                  let parent = fielddict[scope]
                                else
                                  let parent = ''
                                endif
                                let curfielddict = fielddict
                            
                                for i in range(len(tagparts))
                                  let part = tagparts[i]
                                  call s:ProcessTag(part, filename, pattern, curfielddict, i != len(tagparts) - 1, a:typeinfo, a:fileinfo)
                                  if parent !=# ''
                                    let parent = parent . a:typeinfo.sro . part
                                  else
                                    let parent = part
                                  endif
                                  let curfielddict = copy(fielddict)
                                  let curfielddict[scope] = parent
                                endfor
                              else
                                call s:ProcessTag(tagname, filename, pattern, fielddict, 0, a:typeinfo, a:fileinfo)
                              endif

FUNCTION  SpaceVim#plugins#projectmanager#current_root()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\projectmanager.vim:42
Called 2 times
Total time:   0.014932
 Self time:   0.014932

count  total (s)   self (s)
    2              0.014930     return luaeval('require("spacevim.plugin.projectmanager").current_root()')

FUNCTION  <SNR>40_major_mode()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:171
Called 1 time
Total time:   0.000018
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000016   0.000008   let alias = s:LANG.get_alias(&filetype)
    1              0.000002   return empty(alias) ? '' : ' ' . alias . ' '

FUNCTION  <SNR>7_fileformat()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\system.vim:71
Called 1 time
Total time:   0.000024
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000001   let fileformat = ''
    1              0.000001   if &fileformat ==? 'dos'
                                let fileformat = ''
    1              0.000001   elseif &fileformat ==? 'unix'
    1   0.000013   0.000009     if s:isDarwin()
                                  let fileformat = ''
    1              0.000000     else
    1              0.000001       let fileformat = ''
    1              0.000000     endif
                              elseif &fileformat ==? 'mac'
                                let fileformat = ''
    1              0.000000   endif
                            
    1              0.000001   return fileformat

FUNCTION  dein#util#_convert2list()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\util.vim:600
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return type(a:expr) ==# v:t_list ? copy(a:expr) : type(a:expr) ==# v:t_string ?   (a:expr ==# '' ? [] : split(a:expr, '\r\?\n', 1)) : [a:expr]

FUNCTION  <SNR>425_IsHeaderLine()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:31
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:line =~ '^\s*#'

FUNCTION  <SNR>346_getChildren()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:216
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._childlist

FUNCTION  <SNR>452_CreateDirectory()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\mkdir.vim:30
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000002   let d = a:dir
                            
                              " @todo do not skip files that have schemes
    1              0.000007   if d =~? '^[a-z]\+:/'
                                return
    1              0.000000   endif
                            
    1              0.000052   if !isdirectory(d)
                                call s:Mkdirp(d)
    1              0.000001   end

FUNCTION  matchup#pos#equal()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\pos.vim:94
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:pos1 = s:parse_args(a:p1)
                              let l:pos2 = s:parse_args(a:p2)
                              return l:pos1[:1] == l:pos2[:1]

FUNCTION  <SNR>65_hunks()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\VersionControl.vim:135
Called 1 time
Total time:   0.000087
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000001   let hunks = [0,0,0]
    1              0.000000   try
    1   0.000018   0.000013     if SpaceVim#layers#isLoaded('git')
    1   0.000051   0.000012       let hunks = GitGutterGetHunkSummary()
                                else
                                  let hunks = sy#repo#get_stats()
    1              0.000000     endif
                              catch
    1              0.000000   endtry
    1              0.000001   let rst = ''
    1              0.000001   if hunks[0] > 0
    1              0.000002     let rst .= hunks[0] . '+ '
    1              0.000000   endif
    1              0.000001   if hunks[1] > 0
                                let rst .= hunks[1] . '~ '
    1              0.000000   endif
    1              0.000001   if hunks[2] > 0
                                let rst .= hunks[2] . '- '
    1              0.000000   endif
    1              0.000002   return empty(rst) ? '' : ' ' . rst

FUNCTION  <SNR>425_IsBlankLine()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:35
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:line =~ '^$'

FUNCTION  context_filetype#get_filetypes()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:42
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let filetype = call('context_filetype#get_filetype', a:000)
                            
                              let filetypes = [filetype]
                              if filetype =~ '\.'
                                if has_key(g:context_filetype#ignore_composite_filetypes, filetype)
                                  let filetypes = [g:context_filetype#ignore_composite_filetypes[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
                              for ft in copy(filetypes)
                                let filetypes += s:get_same_filetypes(ft)
                              endfor
                            
                              if len(filetypes) > 1
                                let filetypes = s:uniq(filetypes)
                              endif
                            
                              return filetypes

FUNCTION  <SNR>303_EscapeCtagsCmd()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:2999
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('EscapeCtagsCmd called')
                              call tagbar#log#debug('ctags_bin: ' . a:ctags_bin)
                              if type(a:args)==type('')
                                call tagbar#log#debug('ctags_args (is a string): ' . a:args)
                              elseif type(a:args)==type([])
                                call tagbar#log#debug('ctags_args (is a list): ' . string(a:args))
                              endif
                            
                              if exists('+shellslash')
                                let shellslash_save = &shellslash
                                set noshellslash
                              endif
                            
                              "Set up 0th argument of ctags_cmd
                              "a:ctags_bin may have special characters that require escaping.
                              if (&shell =~? 'cmd\.exe$' || &shell =~? 'powershell\.exe$' || &shell =~? 'powershell$' || &shell =~? 'pwsh\.exe$' || &shell =~? 'pwsh$') && a:ctags_bin !~# '\s'
                                "For windows cmd.exe, escaping the 0th argument can cause
                                "problems if it references a batch file and the batch file uses %~dp0.
                                "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                "Only known necessary case is when ctags_bin executable filename has
                                "whitespace character(s).
                            
                                "  Example: If 0th argument is wrapped in double quotes AND it is not
                                "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                "  then %~dp0 resolves to the current working directory rather than
                                "  the batch file's directory. Batch files like this generally exepect
                                "  and depend on %~dp0 to resolve the batch file's directory.
                                "  Note: Documentation such as `help cmd.exe` and
                                "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                "  suggest other special characters that require escaping for command
                                "  line completion.  But tagbar.vim does not use the command line
                                "  completion feature of cmd.exe and testing shows that the only special
                                "  character that needs to be escaped for tagbar.vim is <space> for
                                "  windows cmd.exe.
                                let ctags_cmd = a:ctags_bin
                              else
                                let ctags_cmd = shellescape(a:ctags_bin)
                              endif
                            
                              "Add additional arguments to ctags_cmd
                              if type(a:args)==type('')
                                "When a:args is a string, append the arguments
                                "Note: In this case, do not attempt to shell escape a:args string.
                                "This function expects the string to already be escaped properly for
                                "the shell type. Why not escape? Because it could be ambiguous about
                                "whether a space is an argument separator or included in the argument.
                                "Since escaping rules vary from shell to shell, it is better to pass a
                                "list of arguments to a:args. With a list, each argument is clearly
                                "separated, so shellescape() can calculate the appropriate escaping
                                "for each argument for the current &shell.
                                let ctags_cmd .= ' ' . a:args
                              elseif type(a:args)==type([])
                                "When a:args is a list, shellescape() each argument and append ctags_cmd
                                "Note: It's a better practice to shellescape() each argument separately so that
                                "spaces used as a separator between arguments can be distinguished with
                                "spaces used inside a single argument.
                                for arg in a:args
                                  let ctags_cmd .= ' ' . shellescape(arg)
                                endfor
                              endif
                            
                              "if a filename was specified, add filename as final argument to ctags_cmd.
                              if a:0 == 1
                                let ctags_cmd .= ' ' . shellescape(a:1)
                              endif
                            
                              if exists('+shellslash')
                                let &shellslash = shellslash_save
                              endif
                            
                              " Needed for cases where 'encoding' is different from the system's
                              " encoding
                              if has('multi_byte')
                                if g:tagbar_systemenc != &encoding
                                  let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                elseif $LANG !=# ''
                                  let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
                                endif
                              endif
                            
                              call tagbar#log#debug('Escaped ctags command: ' . ctags_cmd)
                            
                              if ctags_cmd ==# ''
                                if !s:warnings.encoding
                                  call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                  let s:warnings.encoding = 1
                                endif
                              endif
                            
                              return ctags_cmd

FUNCTION  necosyntax#gather_candidates()
    Defined: ~\.SpaceVim\bundle\neco-syntax\autoload\necosyntax.vim:24
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let filetype = &filetype
                              if filetype == ''
                                return []
                              endif
                            
                              if !has_key(s:syntax_list, filetype)
                                call s:make_cache()
                              endif
                            
                              let list = []
                              for ft in s:get_context_filetypes(filetype)
                                let list += get(s:syntax_list, ft, [])
                              endfor
                              return list

FUNCTION  deoplete#custom#_get_option()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:84
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return s:cached.option[a:name]

FUNCTION  SpaceVim#layers#core#statusline#get()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:399
Called 1 time
Total time:   0.002305
 Self time:   0.000262

count  total (s)   self (s)
    3              0.000007   for nr in range(1, winnr('$'))
    2              0.000007     call setwinvar(nr, 'winwidth', winwidth(nr))
    2              0.000004     call setwinvar(nr, 'winid', nr)
    3              0.000002   endfor
    1              0.000003   if &filetype ==# 'vimfiler'
                                return '%#SpaceVim_statusline_ia#'  . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#' . ' vimfiler %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'qf' 
                                if s:VIM.is_qf_win(winnr())
                                  return '%#SpaceVim_statusline_ia#'  . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#' . ' QuickFix %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ( has('patch-8.0.1384')  ? ((getqflist({'title' : 0}).title ==# ':setqflist()') ? '' :  '%#SpaceVim_statusline_c#' . ' ' . getqflist({'title' : 0}).title . '%#SpaceVim_statusline_c_SpaceVim_statusline_z#' . s:lsep ) : '')
                                else
                                  return '%#SpaceVim_statusline_ia#'  . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#' . ' Location List %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ( has('patch-8.0.1384') ? ((getloclist(winnr(),{'title' : 0}).title ==# ':setloclist()') ? '' :  '%#SpaceVim_statusline_c#' . ' ' . getloclist(winnr(),{'title' : 0}).title . '%#SpaceVim_statusline_c_SpaceVim_statusline_z#' . s:lsep ) : '')
                            
                                endif
    1              0.000001   elseif &filetype ==# 'defx'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#' . ' defx ' . '%#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'NvimTree'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#' . ' NvimTree ' . '%#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'Fuzzy'
                                return '%#SpaceVim_statusline_a_bold# Fuzzy %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# %{fuzzy#statusline()} %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep 
    1              0.000001   elseif &filetype ==# 'SpaceVimFindArgv'
                                return '%#SpaceVim_statusline_a_bold# Find %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'rst' && bufname('%') == '__doc__'
                                return '%#SpaceVim_statusline_a_bold# Python Doc %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000002   elseif bufname('%') == '__cheat_output__'
                                return '%#SpaceVim_statusline_a_bold# Vim Cheat %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif bufname('%') == '[Grammarous]'
                                return '%#SpaceVim_statusline_a_bold# Grammarous Info %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'gista-list'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Gista %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000002   elseif &buftype ==# 'terminal'
                                let st =  '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Terminal %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . '%#SpaceVim_statusline_c# ' . matchstr(bufname('%'), '\d\+:\zs.*')
                                if !empty(get(b:, '_spacevim_shell', ''))
                                  let st .= '%#SpaceVim_statusline_c# %{b:_spacevim_shell} %#SpaceVim_statusline_c_SpaceVim_statusline_z#' . s:lsep
                                endif
                                return st
    1              0.000001   elseif &filetype ==# 'vimchat'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Chat %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . '%#SpaceVim_statusline_c# ' . '%{chat#windows#status().protocol}' . ' %#SpaceVim_statusline_c_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# ' . '%{chat#windows#status().channel}' . ' %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . '%#SpaceVim_statusline_c# ' . '%{chat#windows#status().usercount}'
    1              0.000001   elseif &filetype ==# 'git-status'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git status %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'git-commit'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git commit %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' ' . '%#SpaceVim_statusline_c# ' . getcwd()
    1              0.000001   elseif &filetype ==# 'git-rebase'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git rebase %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'git-diff'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git diff %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'git-blame'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git blame %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'git-config'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git config %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'git-log'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Git log %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'calendar'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Calendar %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'vader-result'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Vader result %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'gina-status'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Gina status %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'gina-commit'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Gina commit %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'diff' && bufname('%') =~# '^gina://'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Gina diff %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'nerdtree'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Nerdtree %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'Mundo'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Mundo %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'MundoDiff'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# MundoDiff %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'SpaceVimMessageBuffer'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# Message %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'startify'
                                try
                                  call fugitive#detect(getcwd())
                                catch
                                endtry
                                let st = '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# startify %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
                                if index(g:spacevim_statusline_left, 'vcs') != -1
                                  let st .= '%#SpaceVim_statusline_c#' .  call(s:registed_sections['vcs'], []) . '%#SpaceVim_statusline_c_SpaceVim_statusline_z#' . s:lsep
                                endif
                                return st
    1              0.000002   elseif &buftype ==# 'nofile' && bufname('%') ==# '__LanguageClient__'
                                return '%#SpaceVim_statusline_a# LanguageClient %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# ' . &filetype . ' %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimLayerManager'
                                return '%#SpaceVim_statusline_a#' . s:winnr(1) . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# LayerManager %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimGitLogPopup'
                                return '%#SpaceVim_statusline_a# Git log popup %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'respones.idris'
                                return '%#SpaceVim_statusline_a# Idris Response %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'markdown.lspdoc'
                                return '%#SpaceVim_statusline_a# LSP hover info %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimWinDiskManager'
                                return '%#SpaceVim_statusline_a# WinDisk %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimTodoManager'
                                return '%#SpaceVim_statusline_a# TODO manager %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimTasksInfo'
                                return '%#SpaceVim_statusline_a# Tasks manager %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimGitBranchManager'
                                return '%#SpaceVim_statusline_a# Branch manager %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimPlugManager'
                                return '%#SpaceVim_statusline_a#' . s:winnr(1) . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# PlugManager %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'SpaceVimTabsManager'
                                return '%#SpaceVim_statusline_a#' . s:winnr(1) . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# TabsManager %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'fzf'
                                return '%#SpaceVim_statusline_a_bold# FZF %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# %{SpaceVim#layers#fzf#sources()} %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'denite'
                                return '%#SpaceVim_statusline_a_bold# %{SpaceVim#layers#core#statusline#denite_mode()} ' . '%#SpaceVim_statusline_a_bold_SpaceVim_statusline_b#' . s:lsep . ' ' . '%#SpaceVim_statusline_b#%{SpaceVim#layers#core#statusline#denite_status("sources")} %#SpaceVim_statusline_b_SpaceVim_statusline_z#' . s:lsep . ' ' . '%#SpaceVim_statusline_z#%=%#SpaceVim_statusline_c_SpaceVim_statusline_z#' . s:rsep . '%#SpaceVim_statusline_c# %{SpaceVim#layers#core#statusline#denite_status("path") . SpaceVim#layers#core#statusline#denite_status("linenr")}'
    1              0.000001   elseif &filetype ==# 'denite-filter'
                                return '%#SpaceVim_statusline_a_bold#' . ' Filter ' . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep
    1              0.000001   elseif &filetype ==# 'unite'
                                return '%#SpaceVim_statusline_a_bold#%{SpaceVim#layers#core#statusline#unite_mode()} Unite ' . '%#SpaceVim_statusline_a_bold_SpaceVim_statusline_b#' . s:lsep . ' %{get(unite#get_context(), "buffer_name", "")} ' . '%#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . ' ' . '%#SpaceVim_statusline_c# %{unite#get_status_string()} '
    1              0.000001   elseif &filetype ==# 'SpaceVimFlyGrep'
                                return '%#SpaceVim_statusline_a_bold# FlyGrep %#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# %{SpaceVim#plugins#flygrep#mode()} %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep . '%#SpaceVim_statusline_c# %{getcwd()} %#SpaceVim_statusline_c_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# %{SpaceVim#plugins#flygrep#lineNr()} %#SpaceVim_statusline_b_SpaceVim_statusline_z#' . s:lsep . ' '
    1              0.000001   elseif &filetype ==# 'TransientState'
                                return '%#SpaceVim_statusline_a# Transient State %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'SpaceVimLog'
                                return '%#SpaceVim_statusline_a# SpaceVim Runtime log %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'SpaceVimTomlViewer'
                                return '%#SpaceVim_statusline_a# Toml Json Viewer %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'vimcalc'
                                return '%#SpaceVim_statusline_a#' . s:winnr() . ' VimCalc %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'HelpDescribe'
                                return '%#SpaceVim_statusline_a# HelpDescribe %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'SpaceVimRunner'
                                return '%#SpaceVim_statusline_a# Runner %#SpaceVim_statusline_a_SpaceVim_statusline_b# %{SpaceVim#plugins#runner#status()}'
    1              0.000001   elseif &filetype ==# 'SpaceVimREPL'
                                return '%#SpaceVim_statusline_a#' . ' REPL ' . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . ' %{SpaceVim#plugins#repl#status()}'
    1              0.000001   elseif &filetype ==# 'VimMailClient'
                                return '%#SpaceVim_statusline_a#' . ' VimMail ' . '%#SpaceVim_statusline_a_SpaceVim_statusline_b#' . s:lsep . ' %{mail#client#win#status().dir}'
    1              0.000001   elseif &filetype ==# 'SpaceVimQuickFix'
                                return '%#SpaceVim_statusline_a# SpaceVimQuickFix %#SpaceVim_statusline_a_SpaceVim_statusline_b#'
    1              0.000001   elseif &filetype ==# 'VebuggerShell'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# VebuggerShell %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000001   elseif &filetype ==# 'VebuggerTerminal'
                                return '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b# VebuggerTerminal %#SpaceVim_statusline_b_SpaceVim_statusline_c#' . s:lsep
    1              0.000000   endif
    1              0.000001   if a:0 > 0
    1   0.002054   0.000011     return s:active()
                              else
                                return s:inactive()
                              endif

FUNCTION  neomake#CursorMoved()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2513
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call neomake#EchoCurrentError()
                                call neomake#virtualtext#handle_current_error()

FUNCTION  GetMarkdownIndent()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:47
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if v:lnum > 2 && s:IsBlankLine(getline(v:lnum - 1)) && s:IsBlankLine(getline(v:lnum - 2))
                                    return 0
                                endif
                                let list_ind = get(g:, "vim_markdown_new_list_item_indent", 4)
                                " Find a non-blank line above the current line.
                                let lnum = s:PrevNonBlank(v:lnum - 1)
                                " At the start of the file use zero indent.
                                if lnum == 0 | return 0 | endif
                                let ind = indent(lnum)
                                let line = getline(lnum)    " Last line
                                let cline = getline(v:lnum) " Current line
                                if s:IsLiStart(cline)
                                    " Current line is the first line of a list item, do not change indent
                                    return indent(v:lnum)
                                elseif s:IsHeaderLine(cline) && !s:IsMkdCode(v:lnum)
                                    " Current line is the header, do not indent
                                    return 0
                                elseif s:IsLiStart(line)
                                    if s:IsMkdCode(lnum)
                                        return ind
                                    else
                                        " Last line is the first line of a list item, increase indent
                                        return ind + list_ind
                                    end
                                else
                                    return ind
                                endif

FUNCTION  <SNR>372_GetEndFence()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:356
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return "<!-- " . g:vmt_fence_closing_text . " -->"

FUNCTION  neomake#GetMaker()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:778
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let for_ft = a:0 ? a:1 : 0
                                if type(a:name_or_maker) == type({})
                                    let maker = a:name_or_maker
                                    if !has_key(maker, 'name')
                                        let maker.name = 'unnamed_maker'
                                    endif
                                else
                                    let maker = neomake#get_maker_by_name(a:name_or_maker, for_ft)
                                    if maker is# s:unset_dict
                                        if !a:0
                                            " Check &filetype if no args where provided.
                                            let maker = neomake#get_maker_by_name(a:name_or_maker, &filetype)
                                        endif
                                    endif
                                    if maker is# s:unset_dict
                                        if for_ft isnot# 0
                                            throw printf('Neomake: Maker not found (for %s): %s', !empty(for_ft) ? 'filetype '.for_ft : 'empty filetype', a:name_or_maker)
                                        else
                                            throw printf('Neomake: Maker not found (without filetype): %s', a:name_or_maker)
                                        endif
                                    endif
                                endif
                                return neomake#create_maker_object(maker, a:0 ? a:1 : &filetype)

FUNCTION  matchup#loader#refresh_match_words()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\loader.vim:50
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(b:, 'match_words', ':') !~# ':'
                                call matchup#perf#tic('refresh')
                            
                                " protect the cursor from the match_words function
                                let l:save_pos = matchup#pos#get_cursor()
                                execute 'let l:match_words = ' b:match_words
                                if l:save_pos != matchup#pos#get_cursor()
                                  call matchup#pos#set_cursor(l:save_pos)
                                endif
                            
                                call matchup#perf#toc('refresh', 'function')
                            
                                if has_key(s:match_word_cache, l:match_words)
                                  let b:matchup_delim_lists = s:match_word_cache[l:match_words].delim_lists
                                  let b:matchup_delim_re = s:match_word_cache[l:match_words].delim_regexes
                                  call matchup#perf#toc('refresh', 'cache_hit')
                                else
                                  " re-parse match words
                                  let b:matchup_delim_lists = s:init_delim_lists()
                                  let b:matchup_delim_re = s:init_delim_regexes()
                                  let s:match_word_cache[l:match_words] = { 'delim_lists'  : b:matchup_delim_lists, 'delim_regexes': b:matchup_delim_re,}
                                  call matchup#perf#toc('refresh', 'parse')
                                endif
                              endif

FUNCTION  <SNR>372_GetHeadingName()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:243
Called 4 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    4              0.000021   let l:headingName = substitute(a:headingLine, '^#*\s*', "", "")
    4              0.000017   let l:headingName = substitute(l:headingName, '\s*#*$', "", "")
                            
    4              0.000020   let l:headingName = substitute(l:headingName, '\[\([^\[\]]*\)\]([^()]*)', '\1', "g")
    4              0.000017   let l:headingName = substitute(l:headingName, '\[\([^\[\]]*\)\]\[[^\[\]]*\]', '\1', "g")
                            
    4              0.000003   return l:headingName

FUNCTION  <SNR>56_generate_doc()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\lang\vim.vim:121
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " neovim in windows executable function is broken
                              " https://github.com/neovim/neovim/issues/9391
                              let fd = expand('%:p')
                              let addon_info = s:FILE.findfile('addon-info.json', fd)
                              if !empty(addon_info)
                                let dir = s:FILE.unify_path(addon_info, ':h')
                                if executable('vimdoc') && !s:SYS.isWindows
                                  call s:JOB.start(['vimdoc', dir],  { 'on_exit' : function('s:on_exit'), } )
                                elseif executable('python')
                                  call s:JOB.start(['python', '-m', 'vimdoc', dir],  { 'on_exit' : function('s:on_exit'), } )
                                endif
                              endif

FUNCTION  defx#init#_check_channel()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\init.vim:79
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return exists('g:defx#_channel_id')

FUNCTION  <SNR>324_search_range()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:542
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let stopline_forward = s:stopline_forward()
                              let stopline_back    = s:stopline_back()
                            
                              let cur_text = (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode() ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode() ==# 'i' ? '' : '.'))
                              let curline_pattern = a:start_pattern . '\ze.\{-}$'
                              if cur_text =~# curline_pattern
                                let start = [line('.'), matchend(cur_text, curline_pattern)]
                              else
                                let start = searchpos(a:start_pattern, 'bnceW', stopline_back)
                              endif
                              if start == s:null_pos
                                return s:null_range
                              endif
                              let start[1] += 1
                            
                              let end_pattern = a:end_pattern
                              if end_pattern =~# '\\\@>\d'
                                let lines = getline(start[0], line('.'))
                                let match_list = matchlist(join(lines, "\n"), a:start_pattern)
                                let end_pattern = s:replace_submatch_pattern(end_pattern, match_list)
                              endif
                            
                              let end_forward = searchpos(end_pattern, 'ncW', stopline_forward)
                              if end_forward == s:null_pos
                                let end_forward = [line('$'), len(getline('$'))+1]
                              endi
                            
                              let end_backward = searchpos(end_pattern, 'bnW', stopline_back)
                              if s:pos_less_equal(start, end_backward)
                                return s:null_range
                              endif
                              let end_forward[1] -= 1
                            
                              if mode() !=# 'i' && start[1] >= strdisplaywidth(getline(start[0]))
                                let start[0] += 1
                                let start[1] = 1
                              endif
                            
                              if end_forward[1] <= 1
                                let end_forward[0] -= 1
                                let len = len(getline(end_forward[0]))
                                let len = len ? len : 1
                                let end_forward[1] = len
                              endif
                            
                              return [start, end_forward]

FUNCTION  neomake#utils#get_ft_confname()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\utils.vim:175
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return substitute(a:ft, '\W', a:0 ? a:1 : '_', 'g')

FUNCTION  <SNR>372_GetCodeSections()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:96
Called 1 time
Total time:   0.000480
 Self time:   0.000341

count  total (s)   self (s)
    1              0.000002   let l:codeSections = {}
                            
    1   0.000200   0.000117   call extend(l:codeSections, <SID>GetSections("^```", "^```"))
    1   0.000142   0.000113   call extend(l:codeSections, <SID>GetSections("^\\~\\~\\~", "^\\~\\~\\~"))
    1   0.000133   0.000107   call extend(l:codeSections, <SID>GetSections("^{% highlight", "^{% endhighlight"))
                            
    1              0.000001   return l:codeSections

FUNCTION  <SNR>454_version_std_out()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\ctags.vim:34
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for line in a:data
                                if line =~# 'Universal Ctags'
                                  let s:is_u_ctags = 1
                                  break
                                endif
                              endfor

FUNCTION  deoplete#custom#_get_filetype_option()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:87
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let buffer_option = s:cached.buffer_option
                              if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
                              let option = s:cached.option[a:name]
                              " Check filetype -> a.b filetype -> '_'
                              for filetype in [a:filetype] + split(a:filetype, '\.') + ['_']
                                if has_key(option, filetype)
                                  return option[filetype]
                                endif
                              endfor
                            
                              return a:default

FUNCTION  <SNR>303_Init()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:209
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000002   if s:checked_ctags == 2 && a:silent
                                return 0
    1              0.000001   elseif s:checked_ctags != 1
                                if !s:CheckForExCtags(a:silent)
                                  return 0
                                endif
    1              0.000000   endif
                            
    1              0.000001   if !s:type_init_done
                                call s:InitTypes()
    1              0.000000   endif
                            
    1              0.000001   if !s:autocommands_done
                                call s:CreateAutocommands()
                                call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
    1              0.000000   endif
                            
    1              0.000001   let s:init_done = 1
    1              0.000000   return 1

FUNCTION  <SNR>250_startup_load_bookmarks()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:457
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call BookmarkLoad(s:bookmark_save_file(a:file), 1, 1)
                              call s:add_missing_signs(a:file)

FUNCTION  <SNR>346_addChild()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\basetag.vim:205
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call add(self._childlist, a:tag)
                            
                                if has_key(self._childdict, a:tag.name)
                                    call add(self._childdict[a:tag.name], a:tag)
                                else
                                    let self._childdict[a:tag.name] = [a:tag]
                                endif

FUNCTION  deoplete#handler#_check_omnifunc()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:82
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let prev = g:deoplete#_prev_completion
                              let blacklist = ['LanguageClient#complete']
                              if a:context.event ==# 'Manual' || &l:omnifunc ==# '' || index(blacklist, &l:omnifunc) >= 0 || prev.input ==# a:context.input || s:check_input_method() || deoplete#custom#_get_option('auto_complete_popup') ==# 'manual'
                                return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list( deoplete#custom#_get_filetype_option(   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt(v:true)
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                  endif
                                endfor
                              endfor

FUNCTION  SpaceVim#plugins#mkdir#CreateCurrent()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\mkdir.vim:12
Called 1 time
Total time:   0.000344
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000257   let file = fnamemodify( expand('<afile>'), ':p:h')
    1   0.000086   0.000017   call s:CreateDirectory(file)

FUNCTION  SpaceVim#layers#core#statusline#mode()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:914
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let t = s:colors_template
                              let iedit_mode = get(w:, 'spacevim_iedit_mode', '')
                              let mode = get(w:, 'spacevim_statusline_mode', '')
                              if  mode != a:mode
                                if a:mode ==# 'n'
                                  if !empty(iedit_mode)
                                    if iedit_mode ==# 'n'
                                      exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[8][3] . ' ctermfg=' . t[8][2] . ' guibg=' . t[8][1] . ' guifg=' . t[8][0]
                                    elseif iedit_mode ==# 'i'
                                      exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[7][3] . ' ctermfg=' . t[7][2] . ' guibg=' . t[7][1] . ' guifg=' . t[7][0]
                                    else
                                      exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[0][2] . ' ctermfg=' . t[0][3] . ' guibg=' . t[0][1] . ' guifg=' . t[0][0]
                                    endif
                                  else
                                    exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[0][2] . ' ctermfg=' . t[0][3] . ' guibg=' . t[0][1] . ' guifg=' . t[0][0]
                                  endif
                                elseif a:mode ==# 'i'
                                  exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[4][3] . ' ctermfg=' . t[4][2] . ' guibg=' . t[4][1] . ' guifg=' . t[4][0]
                                elseif a:mode ==# 'R'
                                  exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[6][3] . ' ctermfg=' . t[6][2] . ' guibg=' . t[6][1] . ' guifg=' . t[6][0]
                                elseif a:mode ==# 'v' || a:mode ==# 'V' || a:mode ==# '' || a:mode ==# 's' || a:mode ==# 'S' || a:mode ==# ''
                                  exe 'hi! SpaceVim_statusline_a gui=bold cterm=bold ctermbg=' . t[5][3] . ' ctermfg=' . t[5][2] . ' guibg=' . t[5][1] . ' guifg=' . t[5][0]
                                endif
                                call s:HI.hi_separator('SpaceVim_statusline_a', 'SpaceVim_statusline_b')
                                let w:spacevim_statusline_mode = a:mode
                              endif
                              return ''

FUNCTION  <SNR>454_version_exit()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\ctags.vim:43
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:data ==# 0
                                let s:version_checked = 1
                                call s:LOGGER.info('ctags version checking done:')
                                call s:LOGGER.info('      ctags bin:' . g:gtags_ctags_bin)
                                call ctags#update()
                              endif

FUNCTION  <SNR>345_add_snr()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\normaltag.vim:173
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname

FUNCTION  <SNR>250_lazy_init()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:390
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if g:bm_has_any ==# 0
                                augroup bm_refresh
                                  autocmd!
                                  autocmd ColorScheme * call bm_sign#define_highlights()
                                  autocmd BufLeave * call s:refresh_line_numbers()
                                augroup END
                                let g:bm_has_any = 1
                              endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:50
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  SpaceVim#plugins#scrollbar#show()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\scrollbar.vim:109
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let saved_ei = &eventignore
                              let &ei = 'all'
                              let [winnr, bufnr, winid] = [winnr(), bufnr(), win_getid()]
                              if s:WIN.is_float(winid)
                                call SpaceVim#plugins#scrollbar#clear()
                                let &ei = saved_ei
                                return
                              endif
                            
                              let excluded_filetypes = s:get('excluded_filetypes')
                              if &filetype == '' || index(excluded_filetypes, &filetype) !=# -1
                                call SpaceVim#plugins#scrollbar#clear()
                                let &ei = saved_ei
                                return
                              endif
                            
                              let total = line('$')
                              let height = winheight(winnr)
                              if total <= height
                                call SpaceVim#plugins#scrollbar#clear()
                                let &ei = saved_ei
                                return
                              endif
                            
                              " the position should be based on first line of current screen.
                              let curr_line = line('w0')
                              let bar_size = s:fix_size(height * height / total)
                            
                              let width = winwidth(winnr)
                              let col = width - s:get('width') - s:get('right_offset')
                              " first, you need to know the precision
                              let precision = height - bar_size
                              let each_line = (total - height) * 1.0 / precision
                              let visble_line = min([curr_line, total - height + 1])
                              if each_line >= 1
                                let row = float2nr(visble_line / each_line)
                              else
                                let row = float2nr(visble_line / each_line - 1 / each_line)
                              endif
                            
                              let opts = {  'style' : 'minimal',  'relative' : 'win',  'win' : winid,  'width' : s:get('width'),  'height' : bar_size,  'row' : row,  'col' : float2nr(col),  'focusable' : 0, }
                              if s:WIN.is_float(s:scrollbar_winid)
                                if bar_size !=# s:scrollbar_size
                                  let s:scrollbar_size = bar_size
                                  let bar_lines = s:gen_bar_lines(bar_size)
                                  call s:BUF.buf_set_lines(s:scrollbar_bufnr, 0, -1, 0, bar_lines)
                                  call s:add_highlight(s:scrollbar_bufnr, bar_size)
                                endif
                                noautocmd call s:FLOAT.win_config(s:scrollbar_winid, opts)
                              else
                                let s:scrollbar_size = bar_size
                                let bar_lines = s:gen_bar_lines(bar_size)
                                let s:scrollbar_bufnr = s:create_scrollbar_buffer(bar_size, bar_lines)
                                let s:scrollbar_winid = s:FLOAT.open_win(s:scrollbar_bufnr, 0, opts)
                                if exists('&winhighlight')
                                  call setwinvar(win_id2win(s:scrollbar_winid), '&winhighlight', 'Normal:ScrollbarWinHighlight')
                                endif
                              endif
                              let &ei = saved_ei

FUNCTION  deoplete#util#vimoption2python_not()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:47
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return '[^\w' . s:vimoption2python(a:option) . ']'

FUNCTION  context_filetype#filetypes()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:93
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('b:context_filetype_filetypes')
                                return deepcopy(b:context_filetype_filetypes)
                              endif
                              return extend(deepcopy(s:default_filetypes), deepcopy(g:context_filetype#filetypes))

FUNCTION  <SNR>40_inactive()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:663
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l = '%#SpaceVim_statusline_ia#' . s:winnr(1) . '%#SpaceVim_statusline_ia_SpaceVim_statusline_b#' . s:lsep . '%#SpaceVim_statusline_b#'
                              let secs = [s:filename(), ' ' . &filetype, s:modes()]
                              let base = 10
                              for sec in secs
                                let len = s:STATUSLINE.len(sec)
                                let base += len
                                let l .= '%{ get(w:, "winwidth", 150) < ' . base . ' ? "" : (" ' . s:STATUSLINE.eval(sec) . ' ' . s:ilsep . '")}'
                              endfor
                              if get(w:, 'winwidth', 150) > base + 10
                                let l .= join(['%=', '%{" " . &ff . "|" . (&fenc!=""?&fenc:&enc) . " "}', ' %P '], s:irsep)
                              endif
                              return l

FUNCTION  <SNR>326_is_skip_prev_text()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:256
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let input = deoplete#util#get_input(a:event)
                            
                              " Note: Use g:deoplete#_context is needed instead of
                              " g:deoplete#_prev_completion
                              let prev_input = get(g:deoplete#_context, 'input', '')
                              if input ==# prev_input && input !=# '' && a:event !=# 'Manual' && a:event !=# 'Async' && a:event !=# 'Update' && a:event !=# 'TextChangedP'
                                return 1
                              endif
                            
                              " Note: It fixes insert first candidate automatically problem
                              if a:event ==# 'Update' && prev_input !=# '' && input !=# prev_input
                                return 1
                              endif
                            
                              return 0

FUNCTION  defx#util#convert2list()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:30
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  neoinclude#util#get_buffer_config()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:104
Called 5 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    5              0.000012   let default_val = get(a:000, 0, '')
                            
    5              0.000011   if exists(a:buffer_var)
                                return {a:buffer_var}
    5              0.000002   endif
                            
    5              0.000020   let filetype = !has_key(a:user_var, a:filetype) && !has_key(a:default_var, a:filetype) ? '_' : a:filetype
                            
    5              0.000016   return get(a:user_var, filetype,   get(a:default_var, filetype, default_val))

FUNCTION  defx#util#_parse_options_args()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:102
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:parse_options(a:cmdline)

FUNCTION  <SNR>308_has_fresh_changes()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter.vim:162
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>22_neomake_signatures_clear()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\checkers.vim:311
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('s:neomake_cursormoved_timer') && s:neomake_cursormoved_timer != 0
                                call timer_stop(s:neomake_cursormoved_timer)
                              endif
                              let s:last_echoed_error = ''
                              call s:SIG.clear()

FUNCTION  <SNR>425_IsLiStart()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:26
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:line !~ '^ *\([*-]\)\%( *\1\)\{2}\%( \|\1\)*$' &&    a:line =~ '^\s*[*+-] \+'

FUNCTION  defx#init#_user_options()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\init.vim:94
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'auto_cd': v:false, 'auto_recursive_level': 0, 'buffer_name': 'default', 'close': v:false, 'columns': 'mark:indent:icon:filename:type', 'direction': '', 'filtered_files': '', 'floating_preview': v:false, 'focus': v:true, 'ignored_files': '.*', 'listed': v:false, 'new': v:false, 'preview_height': &previewheight, 'preview_width': 40, 'profile': v:false, 'resume': v:false, 'root_marker': '[in] ', 'search': '', 'session_file': '', 'show_ignored_files': v:false, 'sort': 'filename', 'split': 'no', 'toggle': v:false, 'wincol': &columns / 4, 'winheight': 30, 'winrelative': 'editor', 'winrow': &lines / 3, 'winwidth': 90, 'vertical_preview': v:false, }

FUNCTION  defx#util#call_defx()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:73
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [paths, context] = defx#util#_parse_options_args(a:args)
                              call defx#start(paths, context)

FUNCTION  neomake#makers#ft#text#EnabledMakers()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\makers\ft\text.vim:1
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " No makers enabled by default, since text is used as fallback often.
                                return []

FUNCTION  dein#util#_get_lazy_plugins()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\util.vim:625
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return filter(values(g:dein#_plugins), { _, val -> !val.sourced && val.rtp !=# '' })

FUNCTION  <SNR>274_CreateDelimMapFromCms()
    Defined: ~\.SpaceVim\bundle\nerdcommenter\plugin\NERD_commenter.vim:552
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if &filetype ==# '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
                                endif
                                return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  gitgutter#process_buffer()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter.vim:21
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
                              if gitgutter#utility#is_active(a:bufnr)
                            
                                if has('patch-7.4.1559')
                                  let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
                                endif
                                let how = s:setup_path(a:bufnr, l:Callback)
                                if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>254_exists_file()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:223
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>372_GetHeadingLevel()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:154
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000012   return match(a:headingLine, '[^#]')

FUNCTION  deoplete#handler#_check_prev_completion()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:134
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let prev = g:deoplete#_prev_completion
                              if a:event ==# 'Async' || a:event ==# 'Update' || mode() !=# 'i' || empty(get(prev, 'candidates', [])) || s:check_input_method()
                                return
                              endif
                            
                              let input = deoplete#util#get_input(a:event)
                              let complete_str = matchstr(input, '\w\+$')
                              let min_pattern_length = deoplete#custom#_get_option('min_pattern_length')
                              if prev.linenr != line('.') || len(complete_str) < min_pattern_length
                                return
                              endif
                            
                              let mode = deoplete#custom#_get_option('prev_completion_mode')
                              let candidates = copy(prev.candidates)
                            
                              if mode ==# 'filter' || mode ==# 'length'
                                let input = input[prev.complete_position :]
                                let escaped_input = escape(input, '~\.^$[]*')
                                let pattern = substitute(escaped_input, '\w', '\\w*\0', 'g')
                                call filter(candidates, { _, val -> val.word =~? pattern })
                                if mode ==# 'length'
                                  call filter(candidates, { _, val -> len(val.word) > len(input) })
                                endif
                              elseif mode ==# 'mirror'
                                " pass
                              else
                                return
                              endif
                            
                              let g:deoplete#_filtered_prev = { 'complete_position': prev.complete_position, 'candidates': candidates, }
                              return 1

FUNCTION  <SNR>453_Stack()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\gtags.vim:79
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:this = {}
                              let l:this.container = []
                            
                              function! l:this.push(item) abort
                                call add(self.container, a:item)
                              endfunction
                            
                              function! l:this.pop() abort
                                if len(self.container) <= 0
                                  throw 'Stack Empty'
                                endif
                            
                                let l:item = self.container[-1]
                                unlet self.container[-1]
                            
                                return l:item
                              endfunction
                            
                              return l:this

FUNCTION  neoinclude#util#set_dictionary_helper()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:55
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for key in split(a:keys, '\s*,\s*')
                                if !has_key(a:variable, key)
                                  let a:variable[key] = a:pattern
                                endif
                              endfor

FUNCTION  bm#total_count()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:112
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return len(bm#location_list())

FUNCTION  <SNR>303_HandleOnlyWindow()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3511
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tagbarwinnr = bufwinnr(s:TagbarBufName())
                              if tagbarwinnr == -1
                                return
                              endif
                            
                              let vim_quitting = s:vim_quitting
                              let s:vim_quitting = 0
                            
                              let file_open = s:HasOpenFileWindows()
                            
                              if vim_quitting && file_open == 2 && !g:tagbar_autoclose_netrw
                                call tagbar#log#debug('Closing Tagbar due to QuitPre - netrw only remaining window')
                                call s:CloseWindow()
                                return
                              endif
                            
                              if vim_quitting && file_open != 1
                                call tagbar#log#debug('Closing Tagbar window due to QuitPre event')
                                if winnr('$') >= 1
                                  call s:goto_win(tagbarwinnr, 1)
                                endif
                            
                                " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                " correctly set to the previous buffer.
                                if tabpagenr('$') == 1
                                  noautocmd keepalt bdelete
                                endif
                            
                                try
                                  try
                                    quit
                                  catch /.*/ " This can be E173 and maybe others
                                    call s:OpenWindow('')
                                    echoerr v:exception
                                  endtry
                                catch /.*/
                                  echohl ErrorMsg
                                  echo v:exception
                                  echohl None
                                endtry
                              endif

FUNCTION  matchup#perf#timeout()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\perf.vim:79
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return float2nr(s:timeout)

FUNCTION  <SNR>245_try()
    Defined: ~\.SpaceVim\bundle\indent-blankline.nvim\plugin\indent_blankline.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                try
                                    execute a:cmd
                                catch /E12/
                                    return
                                endtry

FUNCTION  <SNR>135_disable_cursorline()
    Defined: ~\.SpaceVim\autoload\SpaceVim\autocmds.vim:80
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &filetype ==# 'denite'
                              else
                                setl nocursorline
                              endif

FUNCTION  SpaceVim#layers#core#tabline#get()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\tabline.vim:184
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tabpage_counts = tabpagenr('$')
                              let all_tabline_items = []
                              let shown_items = []
                            
                              if tabpage_counts > 1
                                let current_tabnr = tabpagenr()
                                let previous_tabnr = s:TAB.previous_tabpagenr()
                                let matched_len = 0
                                for i in range(1, tabpage_counts)
                                  call add(all_tabline_items, s:buffer_item(tabpagebuflist(i)[tabpagewinnr(i) - 1], i))
                                endfor
                                if previous_tabnr < current_tabnr
                                  for i in range(previous_tabnr == 0 ? 1 : previous_tabnr, current_tabnr)
                                    call add(shown_items, all_tabline_items[i - 1])
                                    if s:check_len(shown_items)
                                      let matched_len = 1
                                      call remove(shown_items, 0)
                                    endif
                                  endfor
                                  if !matched_len && current_tabnr < tabpage_counts
                                    for i in range(current_tabnr + 1, tabpage_counts)
                                      call add(shown_items, all_tabline_items[i - 1])
                                      if s:check_len(shown_items)
                                        let matched_len = 1
                                        call remove(shown_items, -1)
                                        break
                                      endif
                                    endfor
                                  endif
                                  if !matched_len && previous_tabnr > 1
                                    for i in reverse(range(1, previous_tabnr - 1))
                                      call insert(shown_items, all_tabline_items[i - 1])
                                      if s:check_len(shown_items)
                                        call remove(shown_items, 0)
                                        break
                                      endif
                                    endfor
                                  endif
                                else
                                  for i in range(current_tabnr, previous_tabnr > tabpage_counts ? tabpage_counts : previous_tabnr)
                                    call add(shown_items, all_tabline_items[i - 1])
                                    if s:check_len(shown_items)
                                      let matched_len = 1
                                      call remove(shown_items, -1)
                                      break
                                    endif
                                  endfor
                                  if !matched_len && current_tabnr > 1
                                    for i in reverse(range(1, current_tabnr - 1))
                                      call insert(shown_items, all_tabline_items[i - 1])
                                      if s:check_len(shown_items)
                                        let matched_len = 1
                                        call remove(shown_items, 0)
                                        break
                                      endif
                                    endfor
                                  endif
                                  if !matched_len && previous_tabnr < tabpage_counts
                                    for i in range(previous_tabnr + 1, tabpage_counts)
                                      call add(shown_items, all_tabline_items[i - 1])
                                      if s:check_len(shown_items)
                                        call remove(shown_items, -1)
                                        break
                                      endif
                                    endfor
                                  endif
                                endif
                                " get the list of displayed items
                                let s:shown_items = shown_items
                                if empty(shown_items)
                                  return ''
                                endif
                                let t = ''
                                let right_hidden_tab_number = shown_items[0].tabnr - 1
                                let left_hidden_tab_number = tabpage_counts - shown_items[-1].tabnr
                                if right_hidden_tab_number > 0
                                  let t .= '%#SpaceVim_tabline_a#'  .  ' << '. right_hidden_tab_number
                                endif
                                if current_tabnr == shown_items[0].tabnr
                                  if s:is_modified(shown_items[0].bufnr)
                                    if right_hidden_tab_number > 0
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_m#' . s:lsep 
                                    endif
                                    let t .= '%#SpaceVim_tabline_m# '
                                  else
                                    if right_hidden_tab_number > 0
                                      let t .= ' ' . s:ilsep 
                                    endif
                                    let t .= '%#SpaceVim_tabline_a# '
                                  endif
                                else
                                  if right_hidden_tab_number > 0
                                    let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep 
                                  endif
                                  let t .= s:is_modified(shown_items[0].bufnr) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                endif
                                let index = 1
                                for item in shown_items[:-2]
                                  if has('tablineat')
                                    let t .=  '%' . index . '@SpaceVim#layers#core#tabline#jump@'
                                  endif
                                  let t .= s:wrap_id(index)
                                  let t .= s:get_no_empty(gettabvar(item.tabnr, '_spacevim_tab_name'), item.bufname)
                                  let index += 1
                                  if item.tabnr == current_tabnr
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_b#' . s:lsep 
                                    else
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep 
                                    endif
                                    let t .= s:is_modified(shown_items[index-1].bufnr) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                  elseif item.tabnr == current_tabnr - 1
                                    " check if current_tabnr is modified
                                    if s:is_modified(s:BUFFER.bufnr())
                                      let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_m#' . s:lsep . '%#SpaceVim_tabline_m# '
                                    else
                                      let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_a#' . s:lsep . '%#SpaceVim_tabline_a# '
                                    endif
                                  else
                                    let t .= s:is_modified(shown_items[index-1].bufnr) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                    let t .= s:ilsep . ' '
                                  endif
                                endfor
                                let item = shown_items[-1]
                                if has('tablineat')
                                  let t .=  '%' . index . '@SpaceVim#layers#core#tabline#jump@'
                                endif
                                let t .= s:wrap_id(index) . s:get_no_empty(gettabvar(item.tabnr, '_spacevim_tab_name'), item.bufname)
                                if item.tabnr == current_tabnr
                                  if left_hidden_tab_number > 0 
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_a#' . s:lsep
                                      let t .= ' %#SpaceVim_tabline_a#'  . left_hidden_tab_number . ' >>'
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    else
                                      let t .= ' ' . s:ilsep
                                      let t .= ' ' . left_hidden_tab_number . ' >>'
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    endif
                                  else
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    else
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    endif
                                  endif
                                else
                                  if left_hidden_tab_number > 0 
                                    let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_a#' . s:lsep
                                    let t .= ' %#SpaceVim_tabline_a#'  . left_hidden_tab_number . ' >>'
                                    let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                  else
                                    let t .= ' ' . s:ilsep
                                  endif
                                endif
                                " how many buffers after the last item are hidden?
                                let t .= '%=%#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:rsep
                                let t .= '%#SpaceVim_tabline_a# Tabs '
                                return t
                              else
                                let s:buffers = s:BUFFER.listed_buffers()
                                if empty(s:buffers)
                                  return ''
                                endif
                                for i in range(len(s:buffers))
                                  call add(all_tabline_items, s:buffer_item(s:buffers[i]))
                                endfor
                                let current_buf_index = index(s:buffers, s:BUFFER.bufnr())
                                let previous_buf_index =  index(s:buffers, s:BUFFER.bufnr('#'))
                                let matched_len = 0
                                if current_buf_index ==# -1
                                  let shown_items = filter(s:shown_items, 'buflisted(v:val.bufnr)')
                                else
                                  if previous_buf_index < current_buf_index
                                    if previous_buf_index == -1
                                      let previous_buf_index = 0
                                    endif
                                    for i in range(previous_buf_index, current_buf_index)
                                      call add(shown_items, all_tabline_items[i])
                                      if s:check_len(shown_items)
                                        let matched_len = 1
                                        call remove(shown_items, 0)
                                      endif
                                    endfor
                                    if !matched_len && current_buf_index < len(s:buffers) - 1
                                      for i in range(current_buf_index + 1, len(s:buffers) - 1)
                                        call add(shown_items, all_tabline_items[i])
                                        if s:check_len(shown_items)
                                          let matched_len = 1
                                          call remove(shown_items, -1)
                                          break
                                        endif
                                      endfor
                                    endif
                                    if !matched_len && previous_buf_index > 0
                                      for i in reverse(range(0, previous_buf_index - 1))
                                        call insert(shown_items, all_tabline_items[i])
                                        if s:check_len(shown_items)
                                          call remove(shown_items, 0)
                                          break
                                        endif
                                      endfor
                                    endif
                                  else
                                    if previous_buf_index == -1
                                      let previous_buf_index = len(s:buffers) - 1
                                    endif
                                    for i in range(current_buf_index, previous_buf_index)
                                      call add(shown_items, all_tabline_items[i])
                                      if s:check_len(shown_items)
                                        let matched_len = 1
                                        call remove(shown_items, -1)
                                        break
                                      endif
                                    endfor
                                    if !matched_len && current_buf_index > 0
                                      for i in reverse(range(0, current_buf_index - 1))
                                        call insert(shown_items, all_tabline_items[i])
                                        if s:check_len(shown_items)
                                          let matched_len = 1
                                          call remove(shown_items, 0)
                                          break
                                        endif
                                      endfor
                                    endif
                                    if !matched_len && previous_buf_index < len(s:buffers) - 1
                                      for i in range(previous_buf_index + 1, len(s:buffers) - 1)
                                        call add(shown_items, all_tabline_items[i])
                                        if s:check_len(shown_items)
                                          call remove(shown_items, -1)
                                          break
                                        endif
                                      endfor
                                    endif
                                  endif
                                  let s:shown_items = shown_items
                                  let g:_spacevim_list_buffers = map(deepcopy(s:shown_items), 'v:val.bufnr')
                                endif
                                if empty(shown_items)
                                  return ''
                                endif
                                let t = ''
                                " how many buffers before the first item are hidden.
                                let right_hidden_buffer_number = index(s:buffers, shown_items[0].bufnr)
                                let left_hidden_buffer_number = len(s:buffers) - 1 - index(s:buffers, shown_items[-1].bufnr)
                                if right_hidden_buffer_number > 0
                                  let t .= '%#SpaceVim_tabline_a#'  .  ' << '. right_hidden_buffer_number
                                endif
                                if s:BUFFER.bufnr() == shown_items[0].bufnr
                                  if s:is_modified(shown_items[0].bufnr)
                                    if right_hidden_buffer_number > 0
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_m#' . s:lsep 
                                    endif
                                    let t .= '%#SpaceVim_tabline_m# '
                                  else
                                    if right_hidden_buffer_number > 0
                                      let t .= ' ' . s:ilsep 
                                    endif
                                    let t .= '%#SpaceVim_tabline_a# '
                                  endif
                                else
                                  if right_hidden_buffer_number > 0
                                    let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep 
                                  endif
                                  let t .= s:is_modified(shown_items[0].bufnr) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                endif
                                let index = 1
                                for item in shown_items[:-2]
                                  if has('tablineat')
                                    let t .=  '%' . index . '@SpaceVim#layers#core#tabline#jump@'
                                  endif
                                  let t .= s:wrap_id(index) . item.bufname
                                  let index += 1
                                  if item.bufnr == s:BUFFER.bufnr()
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_b#' . s:lsep
                                    else
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep
                                    endif
                                    let t .= s:is_modified(s:buffers[index(s:buffers, item.bufnr) + 1]) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                  elseif index(s:buffers, s:BUFFER.bufnr()) > 0 && item.bufnr == s:buffers[index(s:buffers, s:BUFFER.bufnr()) - 1]
                                    if s:is_modified(s:BUFFER.bufnr())
                                      let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_m#' . s:lsep . '%#SpaceVim_tabline_m# '
                                    else
                                      let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_a#' . s:lsep . '%#SpaceVim_tabline_a# '
                                    endif
                                  else
                                    let t .= s:is_modified(s:buffers[index(s:buffers, item.bufnr) + 1]) ? '%#SpaceVim_tabline_m_i# ' : '%#SpaceVim_tabline_b# '
                                    let t .= s:ilsep . ' '
                                  endif
                                endfor
                                let item = shown_items[-1]
                                if has('tablineat')
                                  let t .=  '%' . index . '@SpaceVim#layers#core#tabline#jump@'
                                endif
                                let t .= s:wrap_id(index) . item.bufname
                                if item.bufnr == s:BUFFER.bufnr()
                                  if left_hidden_buffer_number > 0 
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_a#' . s:lsep
                                      let t .= ' %#SpaceVim_tabline_a#'  . left_hidden_buffer_number . ' >>'
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    else
                                      let t .= ' ' . s:ilsep
                                      let t .= ' ' . left_hidden_buffer_number . ' >>'
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    endif
                                  else
                                    if s:is_modified(item.bufnr)
                                      let t .= ' %#SpaceVim_tabline_m_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    else
                                      let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                    endif
                                  endif
                                else
                                  if left_hidden_buffer_number > 0 
                                    let t .= ' %#SpaceVim_tabline_b_SpaceVim_tabline_a#' . s:lsep
                                    let t .= ' %#SpaceVim_tabline_a#'  . left_hidden_buffer_number . ' >>'
                                    let t .= ' %#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:lsep . '%#SpaceVim_tabline_b#'
                                  else
                                    let t .= ' ' . s:ilsep
                                  endif
                                endif
                                " how many buffers after the last item are hidden?
                                let t .= '%=%#SpaceVim_tabline_a_SpaceVim_tabline_b#' . s:rsep
                                let t .= '%#SpaceVim_tabline_a# Buffers '
                                return t
                              endif

FUNCTION  <SNR>321_vimoption2python()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:50
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let has_dash = 0
                              let patterns = []
                              for pattern in split(a:option, ',')
                                if pattern =~# '\d\+'
                                  let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
                                endif
                            
                                if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
                                elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
                                  let has_dash = 1
                                else
                                  " Avoid ambiguous Python 3 RE syntax for nested sets
                                  if pattern =~# '^--'
                                    let pattern = '\' . pattern
                                  elseif pattern =~# '--$'
                                    let pattern = split(pattern, '-')[0] . '-\-'
                                  endif
                            
                                  call add(patterns, pattern)
                                endif
                              endfor
                            
                              " Dash must be last.
                              if has_dash
                                call add(patterns, '-')
                              endif
                            
                              return join(deoplete#util#uniq(patterns), '')

FUNCTION  <SNR>253_on_bufenter()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\plugin\gitgutter.vim:221
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
                              if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
                              endif
                            
                              if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
                                call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
                              endif

FUNCTION  <SNR>303_ProcessFile()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1209
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('ProcessFile called [' . a:fname . ']')
                            
                              if !s:IsValidFile(a:fname, a:ftype)
                                call tagbar#log#debug('Not a valid file, returning')
                                return
                              endif
                            
                              let l:bufnum = bufnr(a:fname)
                            
                              if !bufloaded(l:bufnum)
                                call tagbar#log#debug('[ProcessFile] Buffer is not loaded exiting...')
                                return
                              endif
                              if !bufexists(l:bufnum)
                                call tagbar#log#debug('[ProcessFile] Buffer does not exist exiting...')
                                return
                              endif
                            
                              let typeinfo = s:known_types[a:ftype]
                            
                              " If the file has only been updated preserve the fold states, otherwise
                              " create a new entry
                              if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
                                let fileinfo = s:known_files.get(a:fname)
                                let typeinfo = fileinfo.typeinfo
                                call fileinfo.reset()
                              else
                                if exists('#TagbarProjects#User')
                                  execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                  if exists('b:tagbar_type')
                                    let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                    call typeinfo.createKinddict()
                                  endif
                                endif
                                let fileinfo = tagbar#prototypes#fileinfo#new(a:fname, a:ftype, typeinfo)
                              endif
                            
                              call tagbar#log#debug('typeinfo for file to process: ' . string(typeinfo))
                            
                              if g:tagbar_file_size_limit > 0 && fileinfo.fsize > g:tagbar_file_size_limit && !exists('b:tagbar_force_update')
                                call tagbar#log#debug('File size exceeds defined limit')
                                let fileinfo.fsize_exceeded = 1
                                call s:known_files.put(fileinfo)
                                return
                              elseif g:tagbar_use_cache
                                " Use a temporary files for ctags processing instead of the original one.
                                " This allows using Tagbar for files accessed with netrw, and also doesn't
                                " slow down Tagbar for files that sit on slow network drives.
                                let tempfile = tempname()
                                let ext = fnamemodify(fileinfo.fpath, ':e')
                                if ext !=# ''
                                  let tempfile .= '.' . ext
                                endif
                            
                                call tagbar#log#debug('Caching file into: ' . tempfile)
                                let templines = getbufline(fileinfo.bufnr, 1, '$')
                                let res = writefile(templines, tempfile)
                            
                                if res != 0
                                  call tagbar#log#debug('Could not create copy '.tempfile)
                                  return
                                endif
                                let fileinfo.mtime = getftime(tempfile)
                                let fileinfo.fsize_exceeded = 0
                            
                                let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
                                if !tagbar#log#debug_enabled()
                                  call delete(tempfile)
                                endif
                              else
                                call tagbar#log#debug('File caching disabled')
                                let fileinfo.fsize_exceeded = 0
                                let ctags_output = s:ExecuteCtagsOnFile(a:fname, a:fname, typeinfo)
                              endif
                            
                              if ctags_output == -1
                                call tagbar#log#debug('Ctags error when processing file')
                                " Put an empty entry into known_files so the error message is only
                                " shown once
                                call s:known_files.put({}, a:fname)
                                return
                              elseif ctags_output ==# ''
                                call tagbar#log#debug('Ctags output empty')
                                " No need to go through the tag processing if there are no tags, and
                                " preserving the old fold state isn't necessary either
                                call s:known_files.put(tagbar#prototypes#fileinfo#new(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                return
                              endif
                            
                              call tagbar#log#debug('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                              " Parse the ctags output lines
                              call tagbar#log#debug('Parsing ctags output')
                              let rawtaglist = split(ctags_output, '\n\+')
                              let seen = {}
                              for line in rawtaglist
                                " skip comments and duplicates (can happen when --sort=no)
                                if line =~# '^!_TAG_' || has_key(seen, line)
                                  continue
                                endif
                                if g:tagbar_ignore_anonymous && line =~# '__anon'
                                  call tagbar#log#debug('anonymous tag found - ignoring per tagbar configuration')
                                  continue
                                endif
                            
                                let seen[line] = 1
                            
                                let parts = split(line, ';"')
                                if len(parts) == 2 " Is a valid tag line
                                  call s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
                                endif
                              endfor
                            
                              " Create a placeholder tag for the 'kind' header for folding purposes, but
                              " only for non-scoped tags
                              for kind in typeinfo.kinds
                                if has_key(get(typeinfo, 'kind2scope', {}), kind.short)
                                  continue
                                endif
                            
                                let curtags = filter(copy(fileinfo.getTags()), 'v:val.fields.kind ==# kind.short && ' . '!has_key(v:val, "scope")')
                                call tagbar#log#debug('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
                                if empty(curtags)
                                  continue
                                endif
                            
                                let kindtag          = tagbar#prototypes#kindheadertag#new(kind.long)
                                let kindtag.short    = kind.short
                                let kindtag.numtags  = len(curtags)
                                let kindtag.fileinfo = fileinfo
                            
                                for tag in curtags
                                  let tag.parent = kindtag
                                endfor
                              endfor
                            
                              " Clear old folding information from previous file version to prevent leaks
                              call fileinfo.clearOldFolds()
                            
                              " Sort the tags
                              call fileinfo.sortTags(typeinfo)
                            
                              call s:known_files.put(fileinfo)

FUNCTION  <SNR>122_re_unquoted_match()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:105
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Don't match a:match if it is located in-between unescaped single or double
                              " quotes
                              return a:match . '\v\ze([^"' . "'" . '\\]*(\\.|"([^"\\]*\\.)*[^"\\]*"|' . "'" . '([^' . "'" . '\\]*\\.)*[^' . "'" . '\\]*' . "'" . '))*[^"' . "'" . ']*$'

FUNCTION  <SNR>122_truncate()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:304
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ? printf('%-' . a:width . 's', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = strwidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = strwidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret

FUNCTION  neosnippet#helpers#get_snippets()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\helpers.vim:25
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mode = get(a:000, 0, mode())
                            
                              call neosnippet#init#check()
                            
                              let neosnippet = neosnippet#variables#current_neosnippet()
                              let snippets = copy(neosnippet.snippets)
                              for filetype in s:get_sources_filetypes(neosnippet#helpers#get_filetype())
                                call neosnippet#commands#_make_cache(filetype)
                                call extend(snippets, neosnippet#variables#snippets()[filetype])
                              endfor
                            
                              let cur_text = neosnippet#util#get_cur_text()
                            
                              if mode ==# 'i' || mode ==# 's'
                                " Special filters.
                                if !s:is_beginning_of_line(cur_text)
                                  call filter(snippets, '!v:val.options.head')
                                endif
                              endif
                            
                              call filter(snippets, "cur_text =~# get(v:val, 'regexp', '')")
                            
                              if exists('b:neosnippet_disable_snippet_triggers')
                                call filter(snippets, 'index(b:neosnippet_disable_snippet_triggers, v:val.word) < 0')
                              endif
                            
                              return snippets

FUNCTION  dein#util#_check_vimrcs()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\util.vim:227
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let time = getftime(dein#util#_get_runtime_path())
                              let ret = !empty(filter(map(copy(g:dein#_vimrcs), { _, val -> getftime(expand(val)) }), { _, val -> time < val }))
                              if !ret
                                return 0
                              endif
                            
                              call dein#clear_state()
                            
                              return ret

FUNCTION  <SNR>372_GetBeginFencePattern()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:360
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001   if a:isModeline != 0
                                return "<!-- " . g:vmt_fence_text . " -->"
    1              0.000000   else
    1              0.000003     return "<!-- " . g:vmt_fence_text . " \\([[:alpha:]]\\+\\)\\? \\?-->"
                              endif

FUNCTION  117()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\clock.vim:32
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.__begin = reltime()
                              let self.__long = 0

FUNCTION  <SNR>445_get_sources_filetypes()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\helpers.vim:177
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes(a:filetype) : split(((a:filetype ==# '') ? 'nothing' : a:filetype), '\.')
                              return neosnippet#util#uniq(['_'] + filetypes + [a:filetype])

FUNCTION  dein#autoload#_on_func()
    Defined: ~\.SpaceVim\bundle\dein.vim\autoload\dein\autoload.vim:169
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let function_prefix = substitute(a:name, '[^#]*$', '', '')
                              if function_prefix =~# '^dein#' || function_prefix =~# '^vital#'
                                return
                              endif
                            
                              call dein#autoload#_source(filter(dein#util#_get_lazy_plugins(),  { _, val -> stridx(function_prefix, val.normalized_name.'#') == 0   || (index(get(val, 'on_func', []), a:name) >= 0) }))

FUNCTION  120()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\clock.vim:45
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   let self.__end = reltimefloat(reltime(self.__begin))
    1              0.000002   return self.__end + self.__long

FUNCTION  124()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\statusline.vim:18
Called 9 times
Total time:   0.000935
 Self time:   0.000055

count  total (s)   self (s)
    9   0.000933   0.000052   return a:len + self.len(a:sec) < a:winwidth

FUNCTION  125()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\statusline.vim:25
Called 17 times
Total time:   0.000982
 Self time:   0.000219

count  total (s)   self (s)
   17              0.000061   let str = matchstr(a:sec, '%{.*}')
   17              0.000016   if !empty(str)
    7              0.000014     let pos = match(str, '}')
    7   0.000837   0.000074     return len(a:sec) - len(str) + len(eval(str[2:pos-1])) + 4
   10              0.000003   else
   10              0.000010     return len(a:sec) + 4
                              endif

FUNCTION  126()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\statusline.vim:35
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(a:sec, '%{.*}', '', 'g')

FUNCTION  127()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\statusline.vim:39
Called 1 time
Total time:   0.001294
 Self time:   0.000257

count  total (s)   self (s)
    1              0.000006   let l = '%#' . a:hi_a . '#' . a:left_sections[0]
    1              0.000004   let l .= '%#' . a:hi_a . '_' . a:hi_b . '#' . a:lsep
    1              0.000001   let flag = 1
    1              0.000001   let len = 0
    6              0.000013   for sec in filter(a:left_sections[1:], '!empty(v:val)')
    5   0.000140   0.000027     if self.check_width(len, sec, a:winwidth)
    5   0.000097   0.000026       let len += self.len(sec)
    5              0.000003       if flag == 1
    3              0.000008         let l .= '%#' . a:hi_b . '#' . sec
    3              0.000009         let l .= '%#' . a:hi_b . '_' . a:hi_c . '#' . a:lsep
    2              0.000001       else
    2              0.000005         let l .= '%#' . a:hi_c . '#' . sec
    2              0.000007         let l .= '%#' . a:hi_c . '_' . a:hi_b . '#' . a:lsep
    5              0.000002       endif
    5              0.000005       let flag = flag * -1
    5              0.000002     endif
    6              0.000002   endfor
    1              0.000003   let l = l[:len(a:lsep) * -1 - 1]
    1              0.000001   if empty(a:right_sections)
                                if flag == 1
                                  return l . '%#' . a:hi_c . '#'
                                else
                                  return l . '%#' . a:hi_b . '#'
                                endif
    1              0.000000   endif
    1   0.000019   0.000005   if self.check_width(len, a:fname, a:winwidth)
    1   0.000013   0.000005     let len += self.len(a:fname)
    1              0.000001     if flag == 1
                                  let l .= '%#' . a:hi_c . '_' . a:hi_z . '#' . a:lsep . '%#' . a:hi_z . '#' . a:fname . '%='
    1              0.000000     else
    1              0.000005       let l .= '%#' . a:hi_b . '_' . a:hi_z . '#' . a:lsep . '%#' . a:hi_z . '#' . a:fname . '%='
    1              0.000000     endif
                              else
                                if flag == 1
                                  let l .= '%#' . a:hi_c . '_' . a:hi_z . '#' . a:lsep . '%='
                                else
                                  let l .= '%#' . a:hi_b . '_' . a:hi_z . '#' . a:lsep . '%='
                                endif
    1              0.000000   endif
    1   0.000776   0.000008   if self.check_width(len, a:tag, a:winwidth) && g:spacevim_enable_statusline_tag
                                let l .= '%#' . a:hi_z . '#' . a:tag
    1              0.000000   endif
    1              0.000004   let l .= '%#' . a:hi_b . '_' . a:hi_z . '#' . a:rsep
    1              0.000001   let flag = 1
    3              0.000005   for sec in filter(a:right_sections, '!empty(v:val)')
    2   0.000052   0.000011     if self.check_width(len, sec, a:winwidth)
    2   0.000034   0.000011       let len += self.len(sec)
    2              0.000001       if flag == 1
    1              0.000004         let l .= '%#' . a:hi_b . '#' . sec
    1              0.000004         let l .= '%#' . a:hi_c . '_' . a:hi_b . '#' . a:rsep
    1              0.000000       else
    1              0.000003         let l .= '%#' . a:hi_c . '#' . sec
    1              0.000004         let l .= '%#' . a:hi_b . '_' . a:hi_c . '#' . a:rsep
    2              0.000001       endif
    2              0.000002       let flag = flag * -1
    2              0.000001     endif
    3              0.000001   endfor
    1              0.000002   return l[:-4]

FUNCTION  deoplete#custom#_get_source_vars()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:104
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(s:cached.source_vars, a:name, {})

FUNCTION  <SNR>40_syntax_checking()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:257
Called 1 time
Total time:   0.000039
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000002   if g:spacevim_lint_engine ==# 'neomake'
    1              0.000002     if !exists('g:loaded_neomake')
                                  return ''
    1              0.000000     endif
    1   0.000023   0.000015     let counts = neomake#statusline#LoclistCounts()
    1              0.000002     let warnings = get(counts, 'W', 0)
    1              0.000001     let errors = get(counts, 'E', 0)
    1              0.000002     let l =  warnings ? '%#SpaceVim_statusline_warn# ● ' . warnings . ' ' : ''
    1              0.000003     let l .=  errors ? (warnings ? '' : ' ') . '%#SpaceVim_statusline_error#● ' . errors  . ' ' : ''
    1              0.000001     return l
                              elseif g:spacevim_lint_engine ==# 'ale'
                                if !exists('g:ale_enabled')
                                  return ''
                                endif
                                let counts = ale#statusline#Count(bufnr(''))
                                let warnings = counts.warning + counts.style_warning
                                let errors = counts.error + counts.style_error
                                let l =  warnings ? '%#SpaceVim_statusline_warn# ● ' . warnings . ' ' : ''
                                let l .=  errors ? (warnings ? '' : ' ') . '%#SpaceVim_statusline_error#● ' . errors  . ' ' : ''
                                return l
                              else
                                if !exists(':SyntasticCheck')
                                  return ''
                                endif
                                let l = SyntasticStatuslineFlag()
                                if strlen(l) > 0
                                  return l
                                else
                                  return ''
                                endif
                              endif

FUNCTION  <SNR>126_getbufvar()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:485
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let b_dict = getbufvar(+a:bufnr, '')
                                if empty(b_dict)
                                    " NOTE: it is an empty string for non-existing buffers.
                                    return a:default
                                endif
                                return get(b_dict, a:name, a:default)

FUNCTION  <SNR>303_AutoUpdate()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:2840
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('AutoUpdate called [' . a:fname . ']')
                            
                              " Whether we want to skip actually displaying the tags in Tagbar and only
                              " update the fileinfo
                              let no_display = a:0 > 0 ? a:1 : 0
                            
                              " This file is being loaded due to a quickfix command like vimgrep, so
                              " don't process it
                              if exists('s:tagbar_qf_active')
                                return
                              elseif exists('s:window_opening')
                                " This can happen if another plugin causes the active window to change
                                " with an autocmd during the initial Tagbar window creation. In that
                                " case InitWindow() hasn't had a chance to run yet and things can
                                " break. MiniBufExplorer does this, for example. Completely disabling
                                " autocmds at that point is also not ideal since for example
                                " statusline plugins won't be able to update.
                                call tagbar#log#debug('Still opening window, stopping processing')
                                return
                              endif
                            
                              " Get the filetype of the file we're about to process
                              let bufnr = bufnr(a:fname)
                              let ftype = getbufvar(bufnr, '&filetype')
                            
                              " Don't do anything if we're in the tagbar window
                              if ftype ==# 'tagbar'
                                call tagbar#log#debug('In Tagbar window, stopping processing')
                                return
                              endif
                            
                              " Only consider the main filetype in cases like 'python.django'
                              let sftype = get(split(ftype, '\.'), 0, '')
                              call tagbar#log#debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                              " Don't do anything if the file isn't supported
                              if !s:IsValidFile(a:fname, sftype)
                                call tagbar#log#debug('Not a valid file, stopping processing')
                                let s:nearby_disabled = 1
                                return
                              endif
                            
                              let updated = 0
                            
                              " Process the file if it's unknown or the information is outdated.
                              " Testing the mtime of the file is necessary in case it got changed
                              " outside of Vim, for example by checking out a different version from a
                              " VCS.
                              if s:known_files.has(a:fname)
                                let curfile = s:known_files.get(a:fname)
                                " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                  call tagbar#log#debug('File data outdated, updating [' . a:fname . ']')
                                  call s:ProcessFile(a:fname, sftype)
                                  let updated = 1
                                else
                                  call tagbar#log#debug('File data seems up to date [' . a:fname . ']')
                                endif
                              elseif !s:known_files.has(a:fname)
                                call tagbar#log#debug('New file, processing [' . a:fname . ']')
                                call s:ProcessFile(a:fname, sftype)
                                let updated = 1
                              endif
                            
                              if no_display
                                return
                              endif
                            
                              let fileinfo = s:known_files.get(a:fname)
                            
                              " If we don't have an entry for the file by now something must have gone
                              " wrong, so don't change the tagbar content
                              if empty(fileinfo)
                                call tagbar#log#debug('fileinfo empty after processing [' . a:fname . ']')
                                return
                              endif
                            
                              " Display the tagbar content if the tags have been updated or a different
                              " file is being displayed
                              if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
                                call s:RenderContent(fileinfo)
                              endif
                            
                              " Call setCurrent after rendering so RenderContent can check whether the
                              " same file is being redisplayed
                              if !empty(fileinfo)
                                call tagbar#log#debug('Setting current file [' . a:fname . ']')
                                call tagbar#state#set_current_file(fileinfo)
                                let s:nearby_disabled = 0
                              endif
                            
                              call s:HighlightTag(0, 1)
                              call s:SetStatusLine()
                              call tagbar#log#debug('AutoUpdate finished successfully')

FUNCTION  SpaceVim#layers#core#statusline#mode_text()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:944
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let past_mode = &paste ? 'Paste ' . s:ilsep . ' ' : ''
                              let mode_text = ''
                              let iedit_mode = get(w:, 'spacevim_iedit_mode', '')
                              if a:mode ==# 'n'
                                if !empty(iedit_mode)
                                  if iedit_mode ==# 'n'
                                    let mode_text = 'IEDIT-NORMAL'
                                  elseif iedit_mode ==# 'i'
                                    let mode_text = 'IEDIT-INSERT'
                                  endif
                                else
                                  let mode_text = 'NORMAL'
                                endif
                              elseif a:mode ==# 'i'
                                let mode_text = 'INSERT'
                              elseif a:mode ==# 'R'
                                let mode_text = 'REPLACE'
                              elseif a:mode ==# 'v'
                                let mode_text = 'VISUAL'
                              elseif a:mode ==# 'V'
                                let mode_text = 'V-LINE'
                              elseif a:mode ==# ''
                                let mode_text = 'V-BLOCK'
                              elseif a:mode ==# 'c'
                                let mode_text = 'COMMAND'
                              elseif a:mode ==# 't'
                                let mode_text = 'TERMINAL'
                              elseif a:mode ==# 'v' || a:mode ==# 'V' || a:mode ==# '^V' || a:mode ==# 's' || a:mode ==# 'S' || a:mode ==# '^S'
                                let mode_text = 'VISUAL'
                              endif
                              return past_mode . mode_text

FUNCTION  <SNR>306_getKind()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\typeinfo.vim:17
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                                "let idx = self.kinddict[a:kind]
    5              0.000014     let idx = has_key(self.kinddict, a:kind) ? self.kinddict[a:kind] : -1
    5              0.000006     return self.kinds[idx]

FUNCTION  neomake#makers#ft#markdown#SupersetOf()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\makers\ft\markdown.vim:1
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'text'

FUNCTION  <SNR>425_PrevNonBlank()
    Defined: ~\.SpaceVim\bundle\vim-markdown\indent\markdown.vim:39
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let i = a:lnum
                                while i > 1 && s:IsBlankLine(getline(i))
                                    let i -= 1
                                endwhile
                                return i

FUNCTION  SpaceVim#layers#core#statusline#remove_section()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:1049
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if index(g:spacevim_statusline_left, a:name) != -1
                                call remove(g:spacevim_statusline_left, index(g:spacevim_statusline_left, a:name))
                              endif
                              if index(g:spacevim_statusline_right, a:name) != -1
                                call remove(g:spacevim_statusline_right, index(g:spacevim_statusline_left, a:name))
                              endif
                              let &l:statusline = SpaceVim#layers#core#statusline#get(1)

FUNCTION  <SNR>372_HeadingLineRegex()
    Defined: ~\.SpaceVim\bundle\vim-markdown-toc\ftplugin\markdown.vim:66
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return '\v(^.+$\n^\=+$|^.+$\n^\-+$|^#{1,6})'

FUNCTION  154()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\window.vim:76
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:winid > 0 && exists('*nvim_win_get_config')
                                  try
                                    return has_key(nvim_win_get_config(a:winid), 'col')
                                  catch
                                    return 0
                                  endtry
                                else
                                  return 0
                                endif

FUNCTION  155()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\vim\window.vim:101
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('nvim') && exists('*nvim_win_get_config')
                                return len(filter(range(1, winnr('$')), '!has_key(nvim_win_get_config(win_getid(v:val)), "col")'))
                              else
                                return winnr('$')
                              endif

FUNCTION  <SNR>326_completion_timer_start()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:112
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('s:completion_timer')
                                call s:completion_timer_stop()
                              endif
                            
                              let delay = deoplete#custom#_get_option('auto_complete_delay')
                              if delay > 0
                                let s:completion_timer = timer_start( delay, {-> deoplete#handler#_completion_begin(a:event)})
                              else
                                call deoplete#handler#_completion_begin(a:event)
                              endif

FUNCTION  277()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\state.vim:32
Called 1 time
Total time:   0.000013
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000011   0.000009     if !tagbar#is_paused() || a:force_current
    1              0.000001         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  cursorword#timer_callback()
    Defined: ~\.SpaceVim\bundle\vim-cursorword\autoload\cursorword.vim:57
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call cursorword#matchadd()

FUNCTION  <SNR>105_get()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\scrollbar.vim:56
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let val = get(g:, 'scrollbar_' . a:key, v:null)
                              if val ==# v:null
                                return s:default[a:key]
                              endif
                              if s:VIM.is_dict(val)
                                let val = extend(val, s:default[a:key], 'keep')
                              endif
                              return val

FUNCTION  <SNR>303_add_tag_recursive()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:1677
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " If the pathlist is empty we are at the correct scope for the current tag
                              if empty(a:pathlist)
                                " If a child tag got processed before a parent tag then there will
                                " be a pseudotag here as a placeholder. Copy the children over and
                                " then replace the pseudotag with the real one.
                                let pseudotags = []
                                if empty(a:parent)
                                  let name_siblings = a:taginfo.fileinfo.getTagsByName(a:taginfo.name)
                                else
                                  let name_siblings = a:parent.getChildrenByName(a:taginfo.name)
                                endif
                            
                                " Consider a tag as replaceable if the current tag is considered to
                                " have more appropriate information
                                for tag in name_siblings
                                  if (tag.fields.kind ==# '?' || tag.fields.kind ==# a:taginfo.fields.kind) && (tag.isPseudoTag() || (!a:taginfo.isSplitTag() && tag.isSplitTag()))
                                    call add(pseudotags, tag)
                                  endif
                                endfor
                            
                                if len(pseudotags) == 1
                                  let pseudotag = pseudotags[0]
                                  for child in pseudotag.getChildren()
                                    call a:taginfo.addChild(child)
                                    let child.parent = a:taginfo
                                  endfor
                                  if empty(a:parent)
                                    call a:taginfo.fileinfo.removeTag(pseudotag)
                                  else
                                    call a:parent.removeChild(pseudotag)
                                  endif
                                elseif len(pseudotags) > 1
                                  echoerr 'Tagbar: Found duplicate pseudotag; this should never happen!' 'Please contact the script maintainer with an example.' 'Pseudotag name:' pseudotag.name
                                endif
                            
                                " If this is a tag that got created due to splitting up a tag name,
                                " don't replace existing tags of the same kind.
                                if a:taginfo.isSplitTag()
                                  for tag in name_siblings
                                    if tag.fields.kind ==# a:taginfo.fields.kind
                                      return
                                    endif
                                  endfor
                                endif
                            
                                if empty(a:parent)
                                  call a:taginfo.fileinfo.addTag(a:taginfo)
                                else
                                  call a:parent.addChild(a:taginfo)
                                  let a:taginfo.parent = a:parent
                                endif
                                return
                              endif
                            
                            
                              " There is still at least one more scope between the current one and the
                              " one of the current tag, so we have to either find or create the
                              " intermediate tags
                            
                              let grandparent = a:parent
                              let parentname = remove(a:pathlist, 0)
                            
                              if empty(grandparent)
                                let name_siblings = a:taginfo.fileinfo.getTagsByName(parentname)
                              else
                                let name_siblings = grandparent.getChildrenByName(parentname)
                              endif
                              if empty(a:pathlist)
                                " If the current tag is a direct child of the parent we're looking for
                                " then we can also filter the parents based on the scope information
                                let parents = []
                                for tag in name_siblings
                                  if tag.fields.kind ==# '?' || get(a:taginfo.typeinfo.kind2scope, tag.fields.kind, '') ==# a:taginfo.scope
                                    call add(parents, tag)
                                  endif
                                endfor
                              else
                                let parents = name_siblings
                              endif
                            
                              if empty(parents)
                                " No parents found, so either the parent is a pseudotag or it hasn't
                                " been processed yet. Create a pseudotag as a placeholder; if the
                                " actual parent gets processed later it will get replaced.
                                if empty(a:pathlist)
                                  let pseudokind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                else
                                  let pseudokind = '?'
                                endif
                                let parent = s:create_pseudotag(parentname, grandparent, pseudokind, a:taginfo.typeinfo, a:taginfo.fileinfo)
                                if empty(grandparent)
                                  call a:taginfo.fileinfo.addTag(parent)
                                else
                                  call grandparent.addChild(parent)
                                endif
                              elseif len(parents) == 1
                                let parent = parents[0]
                              else
                                " If there are multiple possible parents (c.f. issue #139, or tags
                                " with the same name but a different kind) then we will pick the one
                                " that is closest above the current tag as a heuristic.
                            
                                " Start at line 0 so that pseudotags get included
                                let minline = 0
                                for candidate in parents
                                  " If the line number of the current tag is 0 then we have no way
                                  " of determining the best candidate by comparing line numbers.
                                  " Just use the first one we have.
                                  if a:taginfo.fields.line == 0
                                    let parent = candidate
                                    break
                                  endif
                            
                                  if candidate.fields.line <= a:taginfo.fields.line && candidate.fields.line >= minline
                                    let parent = candidate
                                    let minline = candidate.fields.line
                                  endif
                                endfor
                            
                                if !exists('parent')
                                  " If we still haven't found a parent it must be below the current
                                  " tag, so find the closest parent below the tag. This can happen
                                  " for example in Go.
                                  let maxline = line('$')
                                  for candidate in parents
                                    if candidate.fields.line >= a:taginfo.fields.line && candidate.fields.line <= maxline
                                      let parent = candidate
                                      let maxline = candidate.fields.line
                                    endif
                                  endfor
                                endif
                              endif
                            
                              " If the parent is a pseudotag it may have gotten created as an in-between
                              " tag without proper information about its kind because all if its
                              " children are also pseudotags, so it may be incorrect. If the current tag
                              " is a direct child of a pseudotag then we can derive the correct kind, so
                              " replace it if necessary.
                              if parent.isPseudoTag() && empty(a:pathlist)
                                let parentkind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                if parent.fields.kind ==# '?' || parentkind !=# parent.fields.kind
                                  let parent.fields.kind = parentkind
                                  call parent.initFoldState(s:known_files)
                                endif
                              endif
                            
                              call s:add_tag_recursive(parent, a:taginfo, a:pathlist)

FUNCTION  <SNR>453_on_update_exit()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\gtags.vim:472
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:data > 0 && !g:gtags_silent
                                call s:LOGGER.warn('failed to update gtags, exit data: ' . a:data)
                              endif

FUNCTION  191()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\job.vim:101
Called 2 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000003   let obj = {}
    2              0.000003   let obj._argv = a:argv
    2              0.000002   let obj._opts = a:opts
    2              0.000003   let obj._jobs = self.jobs
                              " @vimlint(EVL103, 1, a:job_id)
                              " @vimlint(EVL103, 1, a:event)
    2              0.000004   function! obj.__on_stdout(id, data, event) abort dict
                                if has_key(self._opts, 'on_stdout')
                                  if a:data[-1] ==# '' && len(a:data) > 1
                                    call self._opts.on_stdout(a:id, [self._eof . a:data[0]] + a:data[1:-2], 'stdout')
                                    let self._eof = ''
                                  elseif len(a:data) > 1
                                    call self._opts.on_stdout(a:id, [self._eof . a:data[0]] + a:data[1:-2], 'stdout')
                                    let self._eof = a:data[-1]
                                  elseif len(a:data) ==# 1 && a:data[-1] ==# '' && !empty(self._eof)
                                    call self._opts.on_stdout(a:id, [self._eof], 'stdout')
                                    let self._eof = ''
                                  elseif len(a:data) ==# 1 && a:data[-1] !=# ''
                                    let self._eof .= a:data[-1]
                                  endif
                                endif
                              endfunction
                            
    2              0.000003   function! obj.__on_stderr(id, data, event) abort dict
                                if has_key(self._opts, 'on_stderr')
                                  if a:data[-1] ==# '' && len(a:data) > 1
                                    call self._opts.on_stderr(a:id, [self._eof . a:data[0]] + a:data[1:-2], 'stderr')
                                    let self._eof = ''
                                  elseif len(a:data) > 1
                                    call self._opts.on_stderr(a:id, [self._eof . a:data[0]] + a:data[1:-2], 'stderr')
                                    let self._eof = a:data[-1]
                                  elseif len(a:data) ==# 1 && a:data[-1] ==# '' && !empty(self._eof)
                                    call self._opts.on_stderr(a:id, [self._eof], 'stderr')
                                    let self._eof = ''
                                  elseif len(a:data) ==# 1 && a:data[-1] !=# ''
                                    let self._eof .= a:data[-1]
                                  endif
                                endif
                              endfunction
    2              0.000003   function! obj.__on_exit(id, data, event) abort dict
                                if has_key(self._opts, 'on_exit')
                                  if has_key(self._jobs, a:id)
                                    " when run JOB.stop(id), it will be removed from _jobs before
                                    " __on_exit function called.
                                    let self._jobs[a:id][1] = a:data ? 'failed' : 'dead'
                                  endif
                                  call self._opts.on_exit(a:id, a:data, 'exit')
                                endif
                              endfunction
                              " @vimlint(EVL103, 0, a:job_id)
                              " @vimlint(EVL103, 0, a:event)
                            
    2              0.000016   let obj = { 'argv': a:argv, 'opts': { '_opts': obj._opts, '_jobs' : obj._jobs, '_eof': '', 'on_stdout': obj.__on_stdout, 'on_stderr': obj.__on_stderr, 'on_exit': obj.__on_exit, } }
    2              0.000003   if has_key(a:opts, 'cwd')
                                call extend(obj.opts, {'cwd' : a:opts.cwd})
    2              0.000001   endif
    2              0.000002   if has_key(a:opts, 'env')
                                call extend(obj.opts, {'env' : a:opts.env})
    2              0.000001   endif
    2              0.000002   return obj

FUNCTION  192()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\job.vim:175
Called 2 times
Total time:   0.021850
 Self time:   0.021755

count  total (s)   self (s)
    2              0.000003   if self.nvim_job
    2              0.000001     try
    2              0.000003       if len(a:000) > 0
    2              0.000002         let opts = a:1
                                  else
                                    let opts = {}
    2              0.000001       endif
    2   0.000109   0.000014       let wrapped = self.warp_nvim(a:argv, opts)
    2              0.021310       let job = jobstart(wrapped.argv, wrapped.opts)
                                catch /^Vim\%((\a\+)\)\=:E903/
                                  return -1
    2              0.000002     endtry
    2              0.000004     if job > 0
    2              0.000014       let msg = ['process '. jobpid(job), 'run']
    2              0.000356       call extend(self.jobs, {job : msg})
                                else
                                  if job == -1
                                    call add(self._message, 'Failed to start job:' . (type(a:argv) == 3 ? a:argv[0] : a:argv) . ' is not executeable')
                                  elseif job == 0
                                    call add(self._message, 'Failed to start job: invalid arguments')
                                  endif
    2              0.000001     endif
    2              0.000002     return job
                              elseif self.vim_job
                                if len(a:000) > 0
                                  let opts = a:1
                                else
                                  let opts = {}
                                endif
                                let id = len(self.jobs) + 1
                                let opts.jobpid = id
                                let wrapped = self.warp(a:argv, opts)
                                if has_key(wrapped.opts, 'cwd') && !has('patch-8.0.0902')
                                  let old_wd = getcwd()
                                  let cwd = expand(wrapped.opts.cwd, 1)
                                  " Avoid error E475: Invalid argument: cwd
                                  call remove(wrapped.opts, 'cwd')
                                  exe 'cd' fnameescape(cwd)
                                endif
                                let job = job_start(wrapped.argv, wrapped.opts)
                                if exists('old_wd')
                                  exe 'cd' fnameescape(old_wd)
                                endif
                                call extend(self.jobs, {id : job})
                                return id
                              else
                                if len(a:000) > 0
                                  let opts = a:1
                                else
                                  let opts = {}
                                endif
                                if has_key(opts, 'cwd')
                                  let old_wd = getcwd()
                                  let cwd = expand(opts.cwd, 1)
                                  exe 'cd' fnameescape(cwd)
                                endif
                                let output = self.vim_co.systemlist(a:argv)
                                if exists('old_wd')
                                  exe 'cd' fnameescape(old_wd)
                                endif
                                let id = -1
                                let s:self.opts = opts
                                if v:shell_error
                                  if has_key(opts,'on_stderr')
                                    let s:self.job_argv = [id, output, 'stderr']
                                    try
                                      doautocmd User SpaceVim_job_stderr
                                    catch
                                      doautocmd User SpaceVim_job_stderr
                                    endtry
                                  endif
                                else
                                  if has_key(opts,'on_stdout')
                                    let s:self.job_argv = [id, output, 'stdout']
                                    try
                                      doautocmd User SpaceVim_job_stdout
                                    catch
                                      doautocmd User SpaceVim_job_stdout
                                    endtry
                                  endif
                                endif
                                if has_key(opts,'on_exit')
                                  let s:self.job_argv = [id, v:shell_error, 'exit']
                                  try
                                    doautocmd User SpaceVim_job_exit
                                  catch 
                                    doautocmd User SpaceVim_job_exit
                                  endtry
                                endif
                                return id
                              endif

FUNCTION  <SNR>250_bookmark_save_file()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:462
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Managing bookmarks per buffer implies saving them to a location based on the
                              " open file (working dir doesn't make much sense unless auto changing the
                              " working directory based on current file location is turned on - but this is
                              " a serious dependency to try and require), so the function used to customize
                              " the bookmarks file location must be based on the current file.
                              " For backwards compatibility reasons, a new function is used.
                              if (g:bookmark_manage_per_buffer ==# 1)
                                return exists("*g:BMBufferFileLocation") ? g:BMBufferFileLocation(a:file) : s:default_file_location()
                              elseif (g:bookmark_save_per_working_dir)
                                return exists("*g:BMWorkDirFileLocation") ? g:BMWorkDirFileLocation() : s:default_file_location()
                              else
                                return g:bookmark_auto_save_file
                              endif

FUNCTION  ctags#update()
    Defined: ~\.SpaceVim\bundle\gtags.vim\autoload\ctags.vim:53
Called 1 time
Total time:   0.005182
 Self time:   0.000267

count  total (s)   self (s)
    1              0.000004   let project_root = getcwd()
    1              0.000002   if !s:version_checked
                                call s:LOGGER.info('start to check ctags version')
                                call s:JOB.start([g:gtags_ctags_bin, '--version'], { 'on_stdout': function('s:version_std_out'), 'on_exit': function('s:version_exit'), })
                                return
    1              0.000000   else
    1              0.000012     call s:LOGGER.info('update ctags database for ' . project_root)
    1              0.000001   endif
    1   0.000392   0.000021   let dir = s:FILE.unify_path(g:tags_cache_dir)  . s:FILE.path_to_fname(project_root)
    1              0.000006   let cmd = [g:gtags_ctags_bin]
    1              0.000001   if s:is_u_ctags
                                let cmd += ['-G']
    1              0.000000   endif
    1              0.000084   if !isdirectory(dir)
                                if !mkdir(dir, 'p')
                                  call s:LOGGER.warn('failed to create data databases dir:' . dir)
                                  " if failed to create databases, then do not run ctags command.
                                  return
                                endif
    1              0.000000   endif
    1              0.000052   if isdirectory(dir)
    1              0.000006     let cmd += ['-R', '--extra=+f', '-o', dir . '/tags', project_root]
    1              0.000031     call s:LOGGER.debug('ctags command:' . string(cmd))
    1   0.004566   0.000022     let jobid = s:JOB.start(cmd, { 'on_stdout' : function('s:on_update_stdout'), 'on_stderr' : function('s:on_update_stderr'), 'on_exit' : function('s:on_update_exit') })
    1              0.000001     if jobid <= 0
                                  call s:LOGGER.debug('failed to start ctags job, return jobid:' . jobid)
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  <SNR>344_addTag()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\prototypes\fileinfo.vim:69
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call add(self._taglist, a:tag)
                            
                                if has_key(self._tagdict, a:tag.name)
                                    call add(self._tagdict[a:tag.name], a:tag)
                                else
                                    let self._tagdict[a:tag.name] = [a:tag]
                                endif

FUNCTION  neosnippet#variables#snippets()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\variables.vim:33
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:snippets')
                                let s:snippets= {}
                              endif
                            
                              return s:snippets

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:73
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  neomake#CursorMovedDelayed()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2523
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('s:cursormoved_timer')
                                    call timer_stop(s:cursormoved_timer)
                                endif
                                let delay = get(g:, 'neomake_cursormoved_delay', 100)
                                let s:cursormoved_timer = timer_start(delay, function('s:cursormoved_delayed_cb'))
                                let s:cursormoved_last_pos = getpos('.')

FUNCTION  neomake#get_maker_by_name()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:746
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let for_ft = a:0 ? a:1 : 0
                                let ft_config = for_ft is# 0 ? &filetype : for_ft
                                let bufnr = bufnr('%')
                                if a:maker_name !~# '\v^\w+$'
                                    throw printf('Neomake: Invalid maker name: "%s"', a:maker_name)
                                endif
                            
                                let maker = neomake#utils#GetSetting('maker', {'name': a:maker_name}, s:unset_dict, ft_config, bufnr)
                                if maker is# s:unset_dict
                                    if a:maker_name ==# 'makeprg'
                                        let maker = s:get_makeprg_maker()
                                    elseif for_ft isnot# 0
                                        let maker = s:GetMakerForFiletype(for_ft, a:maker_name)
                                    else
                                        call neomake#utils#load_global_makers()
                                        let f = 'neomake#makers#'.a:maker_name.'#'.a:maker_name
                                        if exists('*'.f)
                                            let maker = call(f, [])
                                        endif
                                    endif
                                endif
                                if type(maker) != type({})
                                    throw printf('Neomake: Got non-dict for maker %s: %s', a:maker_name, maker)
                                endif
                                if maker isnot# s:unset_dict && !has_key(maker, 'name')
                                    let maker.name = a:maker_name
                                endif
                                return maker

FUNCTION  SpaceVim#mapping#space#refrashLSPC()
    Defined: ~\.SpaceVim\autoload\SpaceVim\mapping\space.vim:790
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Predefined mappings
                              let g:_spacevim_mappings_space.l = {'name' : '+Language Specified'}
                              if !empty(&filetype) && has_key(s:language_specified_mappings, &filetype)
                                call call(s:language_specified_mappings[&filetype], [])
                                let b:spacevim_lang_specified_mappings = g:_spacevim_mappings_space.l
                              endif
                            
                              " Customized mappings
                              if has_key(g:_spacevim_mappings_lang_group_name, &filetype)
                                for argv in g:_spacevim_mappings_lang_group_name[&filetype]
                                  " Only support one layer of groups
                                  if !has_key(g:_spacevim_mappings_space.l, argv[0][0])
                                    let g:_spacevim_mappings_space.l[argv[0][0]] = {'name' : argv[1]}
                                  endif
                                endfor
                              endif
                              if has_key(g:_spacevim_mappings_language_specified_space_custom, &filetype)
                                for argv in g:_spacevim_mappings_language_specified_space_custom[&filetype]
                                  let argv = deepcopy(argv)
                                  let argv[1] = ['l'] + argv[1]
                                  call call('SpaceVim#mapping#space#langSPC', argv)
                                endfor
                              endif

FUNCTION  neoinclude#util#substitute_path_separator()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:48
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  SpaceVim#mapping#space#langSPC()
    Defined: ~\.SpaceVim\autoload\SpaceVim\mapping\space.vim:826
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:has_map_to_spc()
                                return
                              endif
                              let is_visual = a:0 > 0 ? a:1 : 0
                              if a:is_cmd
                                let cmd = ':<C-u>' . a:cmd . '<CR>'
                                let lcmd = a:cmd
                              else
                                let cmd = a:cmd
                                let feedkey_m = a:m =~# 'nore' ? 'n' : 'm'
                                if a:cmd =~? '^<plug>'
                                  let lcmd = 'call feedkeys("\' . a:cmd . '", "' . feedkey_m . '")'
                                else
                                  let lcmd = 'call feedkeys("' . a:cmd . '", "' . feedkey_m . '")'
                                endif
                              endif
                              exe a:m . ' <silent> <buffer> [SPC]' . join(a:keys, '') . ' ' . substitute(cmd, '|', '\\|', 'g')
                              if is_visual
                                if a:m ==# 'nnoremap'
                                  exe 'xnoremap <silent> <buffer> [SPC]' . join(a:keys, '') . ' ' . substitute(cmd, '|', '\\|', 'g')
                                elseif a:m ==# 'nmap'
                                  exe 'xmap <silent> <buffer> [SPC]' . join(a:keys, '') . ' ' . substitute(cmd, '|', '\\|', 'g')
                                endif
                              endif
                              if len(a:keys) == 2
                                let g:_spacevim_mappings_space[a:keys[0]][a:keys[1]] = [lcmd, a:desc]
                              elseif len(a:keys) == 3
                                let g:_spacevim_mappings_space[a:keys[0]][a:keys[1]][a:keys[2]] = [lcmd, a:desc]
                              elseif len(a:keys) == 1
                                let g:_spacevim_mappings_space[a:keys[0]] = [lcmd, a:desc]
                              endif
                              call SpaceVim#mapping#menu(a:desc, '[SPC]' . join(a:keys, ''), lcmd)
                              call extend(g:_spacevim_mappings_prefixs['[SPC]'], get(g:, '_spacevim_mappings_space', {}))

FUNCTION  deoplete#send_event()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete.vim:43
Called 1 time
Total time:   0.000122
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000002   if &l:previewwindow
                                return
    1              0.000000   endif
                            
    1   0.000021   0.000017   let sources = deoplete#util#convert2list(get(a:000, 0, []))
    1   0.000095   0.000016   call deoplete#util#rpcnotify('deoplete_on_event', {'event': a:event, 'sources': sources})

FUNCTION  context_filetype#get_same_filetypes()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:67
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let filetype = call('context_filetype#get_filetype', a:000)
                            
                              let filetypes = []
                              for ft in context_filetype#get_filetypes(filetype)
                                let filetypes += s:get_same_filetypes(ft)
                              endfor
                            
                              if len(filetypes) > 1
                                let filetypes = s:uniq(filetypes)
                              endif
                            
                              return filetypes

FUNCTION  <SNR>40_search_status()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:291
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000002   if exists('*searchcount')
    1              0.000021     let result = searchcount(#{maxcount: 0})
    1              0.000001     if result.total ==# 0
    1              0.000001       return ''
                                else
                                  return ' ' . result.current . '/' . result.total . ' '
                                endif
                              endif
                              let save_cursor = getpos('.')
                              let ct = 0
                              let tt = 0
                              let ctl = split(s:VIMCOMP.execute('keeppatterns .,$s/' . @/ . '//gn', 'silent!'), "\n")
                              if !empty(ctl)
                                let ct = split(ctl[0])[0]
                              endif
                              let ttl = split(s:VIMCOMP.execute('keeppatterns %s/' . @/ . '//gn', 'silent!'), "\n")
                              if !empty(ctl)
                                let tt = split(ttl[0])[0]
                              endif
                              keepjumps call setpos('.', save_cursor)
                              " errmsg in this function should be ignored, otherwise SPC f s will always
                              " print errmsg.
                              let v:errmsg = ''
                              if tt ==# 0
                                return ''
                              else
                                return ' ' . (str2nr(tt) - str2nr(ct) + 1) . '/' . tt . ' '
                              endif

FUNCTION  neomake#get_nearest_error()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2457
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let buf = bufnr('%')
                                let ln = line('.')
                                let ln_errors = []
                            
                                for maker_type in ['file', 'project']
                                    let buf_errors = get(s:current_errors[maker_type], buf, {})
                                    let ln_errors += get(buf_errors, ln, [])
                                endfor
                            
                                if empty(ln_errors)
                                    return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]

FUNCTION  <SNR>126_debug_log()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:35
Called 2 times
Total time:   0.000365
 Self time:   0.000278

count  total (s)   self (s)
    2              0.000005     let context = {'bufnr': bufnr('%')}
    2              0.000001     if a:0
    2              0.000234         call extend(context, a:1)
    2              0.000001     endif
    2   0.000123   0.000037     call neomake#log#debug(printf('automake: %s.', a:msg), context)

FUNCTION  neomake#EchoCurrentError()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2490
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                                " a:1 might be a timer from the VimResized event.
                                let force = a:0 ? a:1 : 0
                            
                                let message = neomake#GetCurrentErrorMsg()
                                if empty(message)
                                    if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
                                    return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  <SNR>324_stopline_forward()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:476
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let stopline_forward = line('.') + g:context_filetype#search_offset
                              return (stopline_forward > line('$')) ? line('$') : stopline_forward

FUNCTION  <SNR>274_SetUpForNewFiletype()
    Defined: ~\.SpaceVim\bundle\nerdcommenter\plugin\NERD_commenter.vim:511
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let filetype = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
                                if filetype =~# '\.' && !has_key(s:delimiterMap, filetype)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let filetype = i
                                            break
                                        endif
                                    endfor
                                endif
                            
                                let b:NERDSexyComMarker = ''
                            
                                if has_key(s:delimiterMap, filetype)
                                    let b:NERDCommenterDelims = s:delimiterMap[filetype]
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
                                    endfor
                                    for i in ['nested', 'nestedAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
                                    endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
                                    let b:NERDCommenterFirstInit = getbufvar(1,'NERDCommenterFirstInit')
                                    if exists('g:NERDAltDelims_'.filetype) && eval('g:NERDAltDelims_'.filetype) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
                                else
                                    let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
                                endif
                            

FUNCTION  deoplete#custom#_get_buffer()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\custom.vim:67
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:deoplete_custom')
                                call deoplete#custom#_init_buffer()
                              endif
                            
                              return b:deoplete_custom

FUNCTION  <SNR>326_is_skip_text()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\handler.vim:278
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let input = deoplete#util#get_input(a:event)
                              if !has('nvim') && iconv(iconv(input, 'utf-8', 'utf-16'), 'utf-16', 'utf-8') !=# input
                                " In Vim8, invalid bytes brokes nvim-yarp.
                                return 1
                              endif
                            
                              let lastchar = matchstr(input, '.$')
                              let skip_multibyte = deoplete#custom#_get_option('skip_multibyte')
                              if skip_multibyte && len(lastchar) != strwidth(lastchar) && empty(get(b:, 'eskk', []))
                                return 1
                              endif
                            
                              let displaywidth = strdisplaywidth(input) + 1
                              let is_virtual = virtcol('.') >= displaywidth
                              if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  { _, val -> val ==# 'Comment' })) || is_virtual
                                  return 1
                                endif
                              endif
                            
                              if a:event =~# '^TextChanged' && s:matched_indentkeys(input) !=# ''
                                call deoplete#util#indent_current_line()
                                return 1
                              endif
                            
                              let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
                              return (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  gitgutter#hunk#summary()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\hunk.vim:20
Called 1 time
Total time:   0.000026
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000026   0.000016   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  deoplete#util#rpcnotify()
    Defined: ~\.SpaceVim\bundle\deoplete.nvim\autoload\deoplete\util.vim:151
Called 1 time
Total time:   0.000079
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000020   0.000017   if !deoplete#init#_channel_initialized()
                                return ''
    1              0.000000   endif
                            
    1              0.000002   let a:context['rpc'] = a:method
                            
    1   0.000036   0.000011   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
    1              0.000000   else
    1              0.000012     call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
    1              0.000000   endif
                            
    1              0.000001   return ''

FUNCTION  defx#util#is_windows()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx\util.vim:26
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:is_windows

FUNCTION  neosnippet#util#uniq()
    Defined: ~\.SpaceVim\bundle\neosnippet.vim\autoload\neosnippet\util.vim:147
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let list = copy(a:list)
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = list[i]
                                if key !=# '' && has_key(seen, key)
                                  call remove(list, i)
                                else
                                  if key !=# ''
                                    let seen[key] = 1
                                  endif
                                  let i += 1
                                endif
                              endwhile
                              return list

FUNCTION  neoinclude#get_path()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:190
Called 1 time
Total time:   0.000067
 Self time:   0.000046

count  total (s)   self (s)
                              " Don't use global path if it is not C or C++
    1              0.000006   let default = (a:filetype ==# 'c' || a:filetype ==# 'cpp' || getbufvar(a:bufnr, '&path') !=# &g:path) ? getbufvar(a:bufnr, '&path') : '.'
    1   0.000059   0.000038   return neoinclude#util#substitute_path_separator( neoinclude#util#get_buffer_config(   a:filetype, 'b:neoinclude_paths',   g:neoinclude#paths, g:neoinclude#_paths,   default))

FUNCTION  neomake#config#get()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\config.vim:53
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return call('neomake#config#get_with_source', [a:name] + a:000)[0]

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\plugin\gitgutter.vim:189
Called 1 time
Total time:   0.000039
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000038   0.000012   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  <SNR>303_ExecuteCtags()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar.vim:3131
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call tagbar#log#debug('Executing ctags command: ' . a:ctags_cmd)
                            
                              if &shell =~# 'fish$'
                                " Reset shell since fish isn't really compatible
                                let shell_save = &shell
                                set shell=sh
                              endif
                            
                              if &shell =~# 'elvish'
                                " Reset shell since Elvish isn't really compatible
                                let shell_save = &shell
                                set shell=sh
                              endif
                            
                              if exists('+shellslash')
                                let shellslash_save = &shellslash
                                set noshellslash
                              endif
                            
                              if &shell =~? 'cmd\.exe'
                                let shellxquote_save = &shellxquote
                                set shellxquote=\"
                                let shellcmdflag_save = &shellcmdflag
                                set shellcmdflag=/s\ /c
                              endif
                            
                              if tagbar#log#debug_enabled()
                                silent 5verbose let ctags_output = system(a:ctags_cmd)
                                call tagbar#log#debug(v:statusmsg)
                                call tagbar#log#debug('Exit code: ' . v:shell_error)
                                redraw!
                              else
                                let py_version = get(g:, 'tagbar_python', 1)
                                silent let ctags_output = s:run_system(a:ctags_cmd, py_version)
                              endif
                            
                              if &shell =~? 'cmd\.exe'
                                let &shellxquote  = shellxquote_save
                                let &shellcmdflag = shellcmdflag_save
                              endif
                            
                              if exists('+shellslash')
                                let &shellslash = shellslash_save
                              endif
                            
                              if exists('shell_save')
                                let &shell = shell_save
                              endif
                            
                              return ctags_output

FUNCTION  neoinclude#util#set_default_dictionary()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude\util.vim:52
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call neoinclude#util#set_dictionary_helper({a:variable}, a:keys, a:value)

FUNCTION  defx#initialize()
    Defined: ~\.SpaceVim\bundle\defx.nvim\autoload\defx.vim:7
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return defx#init#_initialize()

FUNCTION  <SNR>65_git_branch()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\VersionControl.vim:77
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000002   if exists('g:loaded_fugitive')
                                try
                                  let head = exists("*FugitiveHead") ? FugitiveHead() : fugitive#Head()
                                  if empty(head)
                                    call FugitiveDetect(getcwd())
                                    let head = exists("*FugitiveHead") ? FugitiveHead() : fugitive#Head()
                                  endif
                                  if g:spacevim_statusline_unicode == 1
                                    return empty(head) ? '' : '  '.head . ' ' . s:gtm_status()
                                  else
                                    return empty(head) ? '' : ' '.head . ' ' . s:gtm_status()
                                  endif
                                catch
                                endtry
    1              0.000002   elseif exists('g:loaded_git')
    1              0.000002       let prefix = g:spacevim_statusline_unicode ? '' : ''
    1              0.000002       return printf('%%{git#branch#current("%s")}', prefix)
                              endif
                              return ''

FUNCTION  SpaceVim#plugins#searcher#count()
    Defined: ~\.SpaceVim\autoload\SpaceVim\plugins\searcher.vim:84
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   if empty(s:rst)
    1              0.000000     return ''
                              else
                                return ' ' . len(s:rst) . ' items '
                              endif

FUNCTION  <SNR>324_get_nest_impl()
    Defined: ~\.SpaceVim\bundle\context_filetype.vim\autoload\context_filetype.vim:654
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let context = s:get_context(a:filetype, a:context_filetypes, a:prev_context.range)
                              if context.range != s:null_range && context.filetype !=# a:filetype
                                return s:get_nest_impl(context.filetype, a:context_filetypes, context)
                              else
                                return a:prev_context
                              endif

FUNCTION  133()
    Defined: ~\.SpaceVim\autoload\SpaceVim\api\language.vim:23
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   if !empty(a:filetype) && has_key(self.__aliases, a:filetype)
                                return self.__aliases[a:filetype]
    1              0.000000   else
    1              0.000001     return a:filetype
                              endif

FUNCTION  matchup#delim#get_current()
    Defined: ~\.SpaceVim\bundle\vim-matchup\autoload\matchup\delim.vim:28
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:get_delim(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  <SNR>127_log()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\log.vim:34
Called 2 times
Total time:   0.000063
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000003     let context = a:0 ? a:1 : {}
    2   0.000048   0.000034     let verbosity = neomake#utils#get_verbosity(context)
    2              0.000004     let logfile = get(g:, 'neomake_logfile', '')
                            
    2              0.000005     if !s:is_testing && verbosity < a:level && empty(logfile)
    2              0.000001         return
                                endif
                            
                                let msg = s:indent_str . a:msg
                                if a:0
                                    if has_key(a:1, 'options')
                                        let context = copy(a:1.options)
                                        let context.make_id = a:1.make_id
                                    else
                                        let context = copy(a:1)
                                    endif
                                    let msg = printf('[%s.%s:%s:%d] %s', get(context, 'make_id', '-'), get(context, 'id', '-'), get(context, 'bufnr', get(context, 'file_mode', 0) ? '?' : '-'), get(context, 'winnr', winnr()), msg)
                                endif
                            
                                " Use Vader's log for messages during tests.
                                " @vimlint(EVL104, 1, l:timediff)
                                if s:is_testing && (verbosity >= a:level || get(g:, 'neomake_test_log_all_messages', 0))
                                    let timediff = s:reltime_lastmsg()
                                    if timediff !=# '     '
                                        let test_msg = '['.s:short_level_to_name[a:level].' '.timediff.']: '.msg
                                    else
                                        let test_msg = '['.s:level_to_name[a:level].']: '.msg
                                    endif
                            
                                    if exists('*vader#log')
                                        " Might not exist with rpcrequest-based nvim test, or throw errors
                                        " if called too early.
                                        call vader#log(test_msg)
                                    endif
                                    " Only keep context entries that are relevant for / used in the message.
                                    let context = a:0 ? extend(filter(copy(context), "index(['id', 'make_id', 'bufnr', 'winnr'], v:key) != -1"), {'winnr': winnr()}, 'keep') : {}
                                    call add(g:neomake_test_messages, [a:level, a:msg, context])
                                    if index(['.', '!', ')', ']'], a:msg[-1:-1]) == -1
                                        let g:neomake_test_errors += ['Log msg does not end with punctuation: "'.a:msg.'".']
                                    endif
                                elseif verbosity >= a:level
                                    if verbosity > 2
                                        echom 'Neomake: '.msg
                                    else
                                        if a:level ==# 0
                                            echohl ErrorMsg
                                        else
                                            echohl WarningMsg
                                        endif
                                        " Use message without context for non-debug msgs.
                                        echom 'Neomake: '.a:msg
                                        echohl None
                                    endif
                                endif
                                if !empty(logfile)
                                    if !exists('s:logfile_writefile_opts')
                                        " Use 'append' with writefile, but only if it is available.  Otherwise, just
                                        " overwrite the file.  'S' is used to disable fsync in Neovim
                                        " (https://github.com/neovim/neovim/pull/6427).
                                        if has('patch-7.4.503')
                                            let s:logfile_writefile_opts = 'aS'
                                        else
                                            let s:logfile_writefile_opts = ''
                                            echohl WarningMsg
                                            echom 'Neomake: appending to the logfile is not supported in your Vim version.'
                                            echohl NONE
                                        endif
                                    endif
                            
                                    let time = strftime('%H:%M:%S')
                                    if !exists('timediff')
                                        let timediff = s:reltime_lastmsg()
                                    endif
                                    try
                                        call writefile([printf('%s %s [%s %s] %s', time, s:pid, s:short_level_to_name[a:level], timediff, msg)], logfile, s:logfile_writefile_opts)
                                    catch
                                        unlet g:neomake_logfile
                                        call neomake#log#error(printf('Error when trying to write to logfile %s: %s.  Unsetting g:neomake_logfile.', logfile, v:exception))
                                    endtry
                                endif
                                " @vimlint(EVL104, 0, l:timediff)

FUNCTION  neoinclude#initialize()
    Defined: ~\.SpaceVim\bundle\neoinclude.vim\autoload\neoinclude.vim:9
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:initialized
                                return
                              endif
                            
                              let g:neoinclude#ctags_commands = get(g:, 'neoinclude#ctags_commands', {})
                              let g:neoinclude#_ctags_commands = {}
                              let g:neoinclude#ctags_arguments = get(g:, 'neoinclude#ctags_arguments', {})
                              let g:neoinclude#_ctags_arguments = {}
                              let g:neoinclude#max_processes = get(g:, 'neoinclude#max_processes', 20)
                              let g:neoinclude#paths = get(g:, 'neoinclude#paths', {})
                              let g:neoinclude#_paths = {}
                              let g:neoinclude#patterns = get(g:, 'neoinclude#patterns', {})
                              let g:neoinclude#_patterns = {}
                              let g:neoinclude#exprs = get(g:, 'neoinclude#exprs', {})
                              let g:neoinclude#_exprs = {}
                              let g:neoinclude#exts = get(g:, 'neoinclude#exts', {})
                              let g:neoinclude#_exts = {}
                              let g:neoinclude#reverse_exprs = get(g:, 'neoinclude#reverse_exprs', {})
                              let g:neoinclude#_reverse_exprs = {}
                              let g:neoinclude#functions = get(g:, 'neoinclude#functions', {})
                              let g:neoinclude#_functions = {}
                              let g:neoinclude#delimiters = get(g:, 'neoinclude#delimiters', {})
                              let g:neoinclude#_delimiters = {}
                              let g:neoinclude#suffixes = get(g:, 'neoinclude#suffixes', {})
                              let g:neoinclude#_suffixes = {}
                            
                              " Initialize include pattern.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'java,haskell', '^\s*\<import')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'c,cpp', '^\s*#\s*include')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'cs', '^\s*\<using')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'ruby', '^\s*\<\%(load\|require\|require_relative\)\>')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'r', '^\s*source(')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'html,xhtml,xml,markdown,mkd', '\%(src\|href\)="\ze[^"]*$')
                            
                              " Initialize include suffixes.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_suffixes', 'haskell', '.hs')
                            
                              " Initialize include functions.
                              " call neoinclude#util#set_default_dictionary(
                              "       \ 'g:neoinclude#_functions', 'vim',
                              "       \ 'neoinclude#analyze_vim_include_files')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_functions', 'ruby', 'neoinclude#analyze_ruby_include_files')
                            
                              " Initialize filename include expr.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'perl', 'substitute(v:fname, "/", "::", "g")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'java,d', 'substitute(v:fname, "/", ".", "g")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'ruby', 'substitute(v:fname, "\.rb$", "", "")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'python', "substitute(substitute(v:fname, '\\v.*egg%(-info|-link)?$', '', ''), '/', '.', 'g')")
                            
                              " Initialize filename include extensions.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'c', ['h'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'cpp', ['', 'h', 'hpp', 'hxx'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'perl', ['pm'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'java', ['java'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'ruby', ['rb'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'python', ['py', 'py3'])
                            
                              " Initialize filename include delimiter.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_delimiters', 'c,cpp,ruby', '/')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_delimiters', 'html,xhtml,xml,markdown,mkd', '')
                            
                              " Initialize ctags command.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_commands', '_', 'ctags')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_commands', 'go', 'gotags')
                            
                              " Initialize ctags arguments.
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', '_', '')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'vim', '--language-force=vim --extra=fq --fields=+ailmnSz --vim-kinds=-f '. '--regex-vim=''/function!?[ \t]+'. '(([bwtglsa]:)?\w+(\.\w+)+|(g:)?([A-Z]\w*|\w+(#\w+)+)|s:\w+)'. '[ \t]*\(/\1/function/''')
                              if neoinclude#util#is_mac()
                                call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'c', '--c-kinds=+p --fields=+iaS --extra=+q -I__DARWIN_ALIAS,__DARWIN_ALIAS_C,__DARWIN_ALIAS_I,__DARWIN_INODE64 -I__DARWIN_1050,__DARWIN_1050ALIAS,__DARWIN_1050ALIAS_C,__DARWIN_1050ALIAS_I,__DARWIN_1050INODE64 -I__DARWIN_EXTSN,__DARWIN_EXTSN_C -I__DARWIN_LDBL_COMPAT,__DARWIN_LDBL_COMPAT2')
                              else
                                call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'c', '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' . '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              endif
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'cpp', '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '. '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                            
                              augroup neoinclude
                                autocmd!
                              augroup END
                            
                              call neoinclude#include#initialize()
                            
                              let s:initialized = 1

FUNCTION  neomake#map_makers()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake.vim:2580
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let makers = []
                                let errors = []
                                let get_args = a:ft is# -1 ? [] : [a:ft]
                                for maker in a:makers
                                    try
                                        let m = call('neomake#GetMaker', [maker] + get_args)
                                    catch /^Neomake: /
                                        call add(errors, substitute(v:exception, '^Neomake: ', '', '').'.')
                                        unlet maker  " vim73/vim-trusty
                                        continue
                                    endtry
                                    call add(makers, m)
                                    unlet maker  " vim73/vim-trusty
                                endfor
                                if !empty(errors)
                                    let log_context = get(s:make_info, s:make_id, {})
                                    for error in errors
                                        if a:auto_enabled
                                            call neomake#log#debug(error, log_context)
                                        else
                                            call neomake#log#error(error, log_context)
                                        endif
                                    endfor
                                endif
                                " Set auto_enabled, but keep explicitly set value.
                                call map(makers, 'extend(v:val, {''auto_enabled'': a:auto_enabled}, ''keep'')')
                                return makers

FUNCTION  <SNR>40_filesize()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:383
Called 1 time
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    1              0.000117   let l:size = getfsize(bufname('%'))
    1              0.000003   if l:size == 0 || l:size == -1 || l:size == -2
                                return ''
    1              0.000000   endif
    1              0.000001   if l:size < 1024
                                return l:size.' bytes '
    1              0.000001   elseif l:size < 1024*1024
    1              0.000009     return printf('%.1f', l:size/1024.0).'k '
                              elseif l:size < 1024*1024*1024
                                return printf('%.1f', l:size/1024.0/1024.0) . 'm '
                              else
                                return printf('%.1f', l:size/1024.0/1024.0/1024.0) . 'g '
                              endif

FUNCTION  BookmarkSave()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\plugin\bookmark.vim:205
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:refresh_line_numbers()
                              if (bm#total_count() > 0 || (!g:bookmark_save_per_working_dir && !g:bookmark_manage_per_buffer))
                                let serialized_bookmarks = bm#serialize()
                                call writefile(serialized_bookmarks, a:target_file)
                                if (!a:silent)
                                  echo "All bookmarks saved"
                                endif
                              elseif (g:bookmark_save_per_working_dir || g:bookmark_manage_per_buffer)
                                call delete(a:target_file) " remove file, if no bookmarks
                              endif

FUNCTION  <SNR>348_compare_by_line()
    Defined: ~\.SpaceVim\bundle\tagbar\autoload\tagbar\sorting.vim:59
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:tag1.fields.line - a:tag2.fields.line

FUNCTION  <SNR>126_configure_buffer()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:523
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let bufnr = +a:bufnr
                                let ft = getbufvar(bufnr, '&filetype')
                                let config = s:getbufvar(bufnr, 'neomake', {})
                                let old_config = deepcopy(config)
                                if a:0
                                    let args = [config, a:1]
                                    if a:0 > 1 && has_key(a:2, 'delay')
                                        let args += [a:2.delay]
                                    endif
                                    call call('s:parse_events_from_args', args)
                                    call setbufvar(bufnr, 'neomake', config)
                            
                                    let implicit_config = {'custom': 1, 'ignore': 0}
                                else
                                    let implicit_config = {'custom': 0, 'ignore': s:is_buffer_ignored(bufnr)}
                                endif
                            
                                " Register the buffer, and remember if it is custom.
                                if has_key(s:configured_buffers, bufnr)
                                    let old_registration = copy(get(s:configured_buffers, bufnr, {}))
                                    call extend(s:configured_buffers[bufnr], implicit_config, 'force')
                                else
                                    let s:configured_buffers[bufnr] = implicit_config
                            
                                    augroup neomake_automake_clean
                                        autocmd BufWipeout <buffer> call s:neomake_automake_clean(expand('<abuf>'))
                                    augroup END
                                endif
                            
                                if implicit_config.ignore
                                    return s:configured_buffers[bufnr]
                                endif
                            
                                let s:configured_buffers[bufnr].events_config = neomake#config#get('automake.events', {})
                            
                                " Create jobs.
                                let options = a:0 > 1 ? a:2 : {}
                                if has_key(options, 'makers')
                                    let makers = neomake#map_makers(options.makers, ft, 0)
                                    let source = 'options'
                                else
                                    let [makers, source] = neomake#config#get_with_source('automake.enabled_makers')
                                    if makers is g:neomake#config#undefined
                                        unlet makers
                                        let makers = neomake#GetEnabledMakers(ft)
                                    else
                                        let makers = neomake#map_makers(makers, ft, 0)
                                    endif
                                endif
                                let options = {'file_mode': 1, 'ft': ft, 'bufnr': bufnr, 'automake': 1}
                                let jobs = neomake#core#create_jobs(options, makers)
                                let s:configured_buffers[bufnr].maker_jobs = jobs
                                call s:debug_log(printf('configured buffer for ft=%s (%s)', ft, empty(jobs) ? 'no enabled makers' : join(map(copy(jobs), 'v:val.maker.name'), ', ').' ('.source.')'), {'bufnr': bufnr})
                                if old_config != config
                                    call s:debug_log('resetting tick because of config changes')
                                    call setbufvar(bufnr, '_neomake_automake_tick', [])
                                elseif exists('old_registration')
                                    if old_registration != s:configured_buffers[bufnr]
                                        call s:debug_log('resetting tick because of registration changes')
                                        call setbufvar(bufnr, '_neomake_automake_tick', [])
                                    endif
                                else
                                    call s:debug_log('setting tick for new buffer')
                                    call setbufvar(bufnr, '_neomake_automake_tick', [])
                                endif
                            
                                if a:0
                                    " Setup autocommands etc (when called manually)?!
                                    call neomake#configure#automake()
                                endif
                                return config

FUNCTION  <SNR>40_totallines()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core\statusline.vim:192
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   return ' %L '

FUNCTION  <SNR>254_abs_path()
    Defined: ~\.cache\vimfiles\repos\github.com\airblade\vim-gitgutter\autoload\gitgutter\utility.vim:205
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
                              let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>33_save_current_file()
    Defined: ~\.SpaceVim\autoload\SpaceVim\layers\core.vim:923
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:CLOCK.start()
                              profile start .profile.log
                              profile func *
                              profile file *
                              let v:errmsg = ''
                              silent! write
                              if v:errmsg !=# ''
                                echohl ErrorMsg
                                echo  v:errmsg
                                echohl None
                              else
                                echohl Delimiter
                                echo  fnamemodify(bufname(), ':.:gs?[\\/]?/?') . ' written ' . string(s:CLOCK.end()) . 's'
                                echohl None
                              endif
                              profile stop

FUNCTION  <SNR>126_is_buffer_ignored()
    Defined: ~\.SpaceVim\bundle\neomake\autoload\neomake\configure.vim:494
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " TODO: blacklist/whitelist.
                                let bufnr = +a:bufnr
                                let buftype = getbufvar(bufnr, '&buftype')
                                if !empty(buftype)
                                    call s:debug_log(printf('ignoring buffer with buftype=%s', buftype), {'bufnr': bufnr})
                                    return 1
                                endif
                            
                                let ft = getbufvar(bufnr, '&filetype')
                                if index(neomake#config#get('automake.ignore_filetypes', []), ft) != -1
                                    call s:debug_log(printf('ignoring buffer with filetype=%s', ft), {'bufnr': bufnr})
                                    return 1
                                endif

FUNCTION  cursorword#matchadd()
    Defined: ~\.SpaceVim\bundle\vim-cursorword\autoload\cursorword.vim:23
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let enable = get(b:, 'cursorword', get(g:, 'cursorword', 1)) && !has('vim_starting')
                              if !enable && !get(w:, 'cursorword_match') | return | endif
                              let i = (a:0 ? a:1 : mode() ==# 'i' || mode() ==# 'R') && col('.') > 1
                              let line = getline('.')
                              let linenr = line('.')
                              let word = matchstr(line[:(col('.')-i-1)], '\k*$') . matchstr(line[(col('.')-i-1):], '^\k*')[1:]
                              if get(w:, 'cursorword_state', []) ==# [ linenr, word, enable ] | return | endif
                              let w:cursorword_state = [ linenr, word, enable ]
                              if get(w:, 'cursorword_match')
                                silent! call matchdelete(w:cursorword_id0)
                                silent! call matchdelete(w:cursorword_id1)
                              endif
                              let w:cursorword_match = 0
                              if !enable || word ==# '' || len(word) !=# strchars(word) && word !~# s:alphabets || len(word) > 1000 | return | endif
                              let pattern = '\<' . escape(word, '~"\.^$[]*') . '\>'
                              let w:cursorword_id0 = matchadd('CursorWord0', pattern, -100)
                              let w:cursorword_id1 = matchadd('CursorWord' . &l:cursorline, '\%' . linenr . 'l' . pattern, -100)
                              let w:cursorword_match = 1

FUNCTION  bm#serialize()
    Defined: ~\.SpaceVim\bundle\vim-bookmarks\autoload\bm.vim:160
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file_version = "let l:bm_file_version = 1"
                              let sessions  = "let l:bm_sessions = {'default': {"
                              for file in bm#all_files()
                                let sessions .= "'". file ."': ["
                                for bm in values(bm#all_bookmarks_by_line(file))
                                  let escaped_content = substitute(bm['content'], "'", "''", "g")
                                  let escaped_annotation = substitute(bm['annotation'], "'", "''", "g")
                                  let annotation = bm['annotation'] !=# "" ? ", 'annotation': '". escaped_annotation ."'" : ""
                                  let sessions .= "{'sign_idx': ". bm['sign_idx'] .", 'line_nr': ". bm['line_nr'] .", 'content': '". escaped_content ."'". annotation ."},"
                                endfor
                                let sessions .= "],"
                              endfor
                              let sessions .= "}}"
                              let current_session = "let l:bm_current_session = 'default'"
                              return [file_version, sessions, current_session]

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.021850   0.021755  192()
    1   0.018212   0.000457  gtags#update()
    1   0.016523   0.014215  <SNR>460_check_buffer()
    2   0.014932             SpaceVim#plugins#projectmanager#current_root()
    1   0.005182   0.000267  ctags#update()
    1   0.002305   0.000262  SpaceVim#layers#core#statusline#get()
    1   0.002237   0.000580  <SNR>460_get_buffer_include_files()
    1   0.002043   0.000298  <SNR>40_active()
    1   0.001992   0.000073  <SNR>372_UpdateToc()
    1   0.001627   0.000417  <SNR>372_GenTocInner()
    1   0.001294   0.000257  127()
    1   0.001263             <SNR>460_get_include_files()
   17   0.000982   0.000219  125()
    9   0.000935   0.000055  124()
    1   0.000890   0.000346  <SNR>372_GetHeadingLines()
    1   0.000840   0.000083  <SNR>126_neomake_automake()
    1   0.000732   0.000015  SpaceVim#layers#core#statusline#_current_tag()
    1   0.000717   0.000050  tagbar#currenttag()
    1   0.000649   0.000591  <SNR>303_GetNearbyTag()
    4   0.000633             33()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.021850   0.021755  192()
    2              0.014932  SpaceVim#plugins#projectmanager#current_root()
    1   0.016523   0.014215  <SNR>460_check_buffer()
    1              0.001263  <SNR>460_get_include_files()
    4              0.000633  33()
    1   0.000649   0.000591  <SNR>303_GetNearbyTag()
    1   0.002237   0.000580  <SNR>460_get_buffer_include_files()
    1   0.018212   0.000457  gtags#update()
    1   0.001627   0.000417  <SNR>372_GenTocInner()
    1   0.000369   0.000352  cscope#onChange()
    1   0.000890   0.000346  <SNR>372_GetHeadingLines()
    1   0.000480   0.000341  <SNR>372_GetCodeSections()
    1   0.000342   0.000330  defx#util#rpcrequest()
    1   0.002043   0.000298  <SNR>40_active()
    2   0.000365   0.000278  <SNR>126_debug_log()
    1   0.000344   0.000275  SpaceVim#plugins#mkdir#CreateCurrent()
    1   0.000292   0.000269  <SNR>372_DeleteExistingToc()
    1   0.005182   0.000267  ctags#update()
    1   0.002305   0.000262  SpaceVim#layers#core#statusline#get()
    1   0.001294   0.000257  127()

